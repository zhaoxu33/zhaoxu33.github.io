<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode算法题7</title>
    <link href="/leetcode-suan-fa-ti-7/"/>
    <url>/leetcode-suan-fa-ti-7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h2><p><strong>题目</strong>：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659149013/zhaoxu%60s%20blog/2022/ec0f6cde6f335ed28ebbb11449663bc8.jpg" alt="二叉树"></p><p><strong>示例</strong>：</p><blockquote><p>输入：root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]</p><p>输出：true</p></blockquote><p><strong>思路</strong>：双重递归，从每个节点开始进行类似的计算，用第一个递归用来遍历这些节点，第二个递归用来处理这些节点，进行深搜匹配子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isRootSubtree(root,subRoot)||isSubtree(root.left,subRoot)||isSubtree(root.right,subRoot);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRootSubtree</span><span class="hljs-params">(TreeNode root,TreeNode subRoot)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>&amp;&amp;subRoot==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||subRoot==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.val==subRoot.val)&#123;<br>        <span class="hljs-keyword">return</span> isRootSubtree(root.left,subRoot.left)&amp;&amp;isRootSubtree(root.right,subRoot.right);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><p><strong>题目</strong>：给你一个非负整数数组<code> nums</code> ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [2,3,1,1,4]</p><p>输出：2</p></blockquote><p><strong>思路</strong>1：错误方法，时间复杂度和空间复杂度都贼高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    Arrays.fill(dp,Integer.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.length&amp;&amp;j&lt;=i+nums[i])&#123;<br>            dp[j] = Math.min(dp[i]+<span class="hljs-number">1</span>,dp[j]);<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路</strong>2：正确方法，贪心思想。「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,temp = <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>        temp = Math.max(temp,i+nums[i]);<br>        <span class="hljs-keyword">if</span>(i==end)&#123;<br>            end = temp;<br>            result++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题6</title>
    <link href="/leetcode-suan-fa-ti-6/"/>
    <url>/leetcode-suan-fa-ti-6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2><p><strong>题目</strong>：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例</strong>：</p><blockquote><p>输入：prices &#x3D; [3,3,5,0,0,3,1,4]</p><p>输出：6</p></blockquote><p><strong>思路</strong>：动态规划。根据题意划分为4个状态，买一，卖一，买二，卖二。对数组进行遍历，同时对这个4个变量进行更新，最后返回卖2。其中第一天的起始状态为-prices[0],0,-prices[0],0。然后从i&#x3D;1开始进行动态规划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">buy1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,sell1 = <span class="hljs-number">0</span>,buy2 = <span class="hljs-number">0</span>,sell2 = <span class="hljs-number">0</span>,len = prices.length;<br>    <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>        buy1 = -prices[<span class="hljs-number">0</span>];<br>        buy2 = -prices[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; len;i++)&#123;<br>        buy1 = Math.max(buy1,-prices[i]);<br>        sell1 = Math.max(sell1,buy1+prices[i]);<br>        buy2 = Math.max(buy2,sell1-prices[i]);<br>        sell2 = Math.max(sell2,buy2+prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p><strong>题目</strong>：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [0,1,0,3,12]</p><p>输出：[1,3,12,0,0]</p></blockquote><p><strong>思路</strong>：快慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,fast = slow,len = nums.length;<br>    <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[slow];<br>            nums[slow] = nums[fast];<br>            nums[fast] = temp;<br>            slow++;<br>            fast++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            fast++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><strong>题目</strong>：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p><strong>示例</strong>：</p><blockquote><p>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p></blockquote><p><strong>思路</strong>：定义两个优先队列，一个小根堆，一个大根堆。保证这两个队列中的元素个数相差不超过一。每次添加一个元素，先和大根堆的堆顶元素比较。比它小则添加到大根堆，然后判断大根堆的元素个数是否大于小根堆的元素个数+1，若大于，则需弹出一个大根堆的元素添加到小根堆。否则添加到小根堆。然后判断小根堆的元素个数是否大于大根堆的元素个数，若大于，则需弹出一个小根堆的元素添加到大根堆。对于中位数，如果两个优先队列元素个数相等则取两个堆的堆顶元素求平均，否则取大根堆的堆顶元素。</p><p>上面太啰嗦了，主要思想就是，用两个堆的堆顶保存中位数，维护这两个堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; minq;<br>PriorityQueue&lt;Integer&gt; maxq;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>    minq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);<br>    maxq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a-b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-keyword">if</span>(minq.isEmpty()||minq.peek()&gt;=num)&#123;<br>        minq.offer(num);<br>        <span class="hljs-keyword">if</span>(maxq.size()+<span class="hljs-number">1</span>&lt;minq.size())&#123;<br>            maxq.offer(minq.poll());<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        maxq.offer(num);<br>        <span class="hljs-keyword">if</span>(maxq.size()&gt;minq.size())&#123;<br>            minq.offer(maxq.poll());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(minq.size()==maxq.size())&#123;<br>        <span class="hljs-keyword">return</span> (minq.peek()+maxq.peek())/<span class="hljs-number">2.0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> minq.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题5</title>
    <link href="/leetcode-suan-fa-ti-5/"/>
    <url>/leetcode-suan-fa-ti-5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h2><p><strong>题目</strong>：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>操作返回 -1 )</p><p><strong>示例</strong>：</p><blockquote><p>输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>           [[],[3],[],[]]</p><p>输出：[null,null,3,-1]</p></blockquote><p><strong>思路</strong>：一道简单题，用两个栈模拟队列，一个栈只负责进，另一个栈只负责出。当出的栈为空时，将进的栈的所有元素弹出并压入出的栈。这样需要出队时就只用弹出负责出的栈的栈顶元素就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; s1;<br>Stack&lt;Integer&gt; s2;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>    s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    s1.push(value);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(s2.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span>(s1.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!s1.isEmpty())&#123;<br>                s2.push(s1.pop());<br>            &#125;<br>            <span class="hljs-keyword">return</span> s2.pop();<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> s2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p><strong>题目</strong>：给你一个 升序排列 的数组 <code>nums</code>，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组<code>nums</code>的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 <code>nums</code>的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 <code>nums</code>的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums&#x3D; [1,1,2]</p><p>输出：2, nums&#x3D; [1,2,_]</p></blockquote><p><strong>思路</strong>：一道双指针题，用快慢指针。慢指针用来保证删除重复元素后的最后一个数组下标，快指针用来遍历整个数组，将快指针指向的元素与慢指针指向的前一个元素进行比较，相同则快指针往前走一步，不同则说明这是一个不重复的新元素，将其赋值给慢指针，然后各向前走一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,fast = <span class="hljs-number">1</span>,len = nums.length;<br>    <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!=nums[slow-<span class="hljs-number">1</span>])&#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>            fast++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            fast++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h2><p><strong>题目</strong>：给定一个包含红色、白色和蓝色、共 n 个元素的数组 <code>nums</code> ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [2,0,2,1,1,0]</p><p>输出：[0,0,1,1,2,2]</p></blockquote><p><strong>思路</strong>：又是一道双指针题，先定义两个指针，一个指针指向数组头，记录已经排好的0的位置；一个指针指向数组尾，记录已经排好的2的位置，然后对数组进行遍历。如果找到了 0，将其与0指针进行交换，0指针向后移动一个位置；如果找到了2，将其与2指针进行交换，2指针向前移动一个位置；只这样写是不对的，因为我们不能保证交换后的当前值不为2或0，所以我们当我们找到 2 时，我们需要不断地将其与2指针进行交换，直到新的值不为 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt;= b;i++)&#123;<br>        <span class="hljs-keyword">while</span>(i &lt;= b&amp;&amp;nums[i]==<span class="hljs-number">2</span>)&#123;<br>            swap(i,b,nums);<br>            b--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)&#123;<br>            swap(i,a,nums);<br>            a++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题4</title>
    <link href="/leetcode-suan-fa-ti-4/"/>
    <url>/leetcode-suan-fa-ti-4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p><strong>题目</strong>：给你一个大小为 m x n 的二进制矩阵 <code>grid</code>。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 <code>grid</code>的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 <code>grid</code>中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658887229/zhaoxu%60s%20blog/2022/c462d022e77d90bc42de4f86e1ed4e9b.jpg" alt="img"></p><p><strong>示例</strong>：</p><blockquote><p>输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</p><p>输出：6</p></blockquote><p><strong>思路</strong>：经典深度优先搜索题，递归的时候把结果累加。但我写了半天，后来发现是有个变量写错了，看来有时候觉得自己思路没问题的，但结果和自己想的不一样的时候，首先就应该检查一下是不是代码那个地方写错了，看半天，唉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> grid.length,len2 = grid[<span class="hljs-number">0</span>].length,res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len1;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; len2;j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                res = Math.max(backTrack(i,j,grid),res);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span>[][] grid)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    grid[i][j]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] directions = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir:directions)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i+dir[<span class="hljs-number">0</span>],y = j+dir[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=grid.length||y&lt;<span class="hljs-number">0</span>||y&gt;=grid[<span class="hljs-number">0</span>].length||grid[x][y]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cnt+=backTrack(x,y,grid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h2><p><strong>题目</strong>：给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 ( 必须有相应的右括号 )。</li><li>任何右括号 ) 必须有相应的左括号 ( 。</li><li>左括号 ( 必须在对应的右括号之前 )。</li><li>*可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例</strong>：</p><blockquote><p>输入：“(*)”</p><p>输出：True</p></blockquote><p><strong>思路一</strong>：利用栈存储符号的下标，遇到左括号就入s1栈，遇到*号入s2栈，遇到右括号优先弹出s1栈中的下标，否则弹出s2栈中的下标，两者都为空则返回false。遍历完成后，再对s1和s2中剩下的下标进行判断，s1的栈顶数据不能大于s2的栈顶数据，否则返回false。最后判断s1是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>    Deque&lt;Integer&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            s1.push(i);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            s2.push(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(!s1.isEmpty())&#123;<br>                s1.pop();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!s2.isEmpty())&#123;<br>                s2.pop();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!s1.isEmpty()&amp;&amp;!s2.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s1.pop(),j = s2.pop();<br>        <span class="hljs-keyword">if</span>(i &gt; j)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s1.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路二</strong>：贪心解法，空间复杂度优化到O(1)。在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，</p><ul><li>如果遇到左括号，则将最小值和最大值分别加 1；</li><li>如果遇到右括号，则将最小值和最大值分别减 1；</li><li>如果遇到星号，则将最小值减 1，将最大值加 1。</li></ul><p>然后在遍历过程中进行判断，最大值不能小于0。再在最后进行判断，最小值必须等于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,min = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            max++;<br>            min++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            min = Math.max(min-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>            max--;<br>            <span class="hljs-keyword">if</span>(max&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            max++;<br>            min = Math.max(min-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min==<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h2><p><strong>题目</strong>：给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [10,2]</p><p>输出：”210”</p></blockquote><p><strong>思路</strong>：这道题的关键在于，如果一个数排在另一个数前面组成的数大于排在其后面，则不论几个数进行排序，要得到最大的结果，该数就应该排在前面。也就是说这个顺序具有传递性。根据这一点对数据进行比较并排序，再转化为字符串。（写过的题，又忘了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j &lt; nums.length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(compare(nums[i],nums[j]))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>        res.append(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sx</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>,sy = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(sx&lt;=x)&#123;<br>        sx *= <span class="hljs-number">10</span>;<br>    &#125; <br>    <span class="hljs-keyword">while</span>(sy&lt;=y)&#123;<br>        sy *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> y*sx+x-x*sy-y&gt;<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap详解</title>
    <link href="/hashmap-xiang-jie/"/>
    <url>/hashmap-xiang-jie/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a>HashMap详解</h2><h3 id="HashMap的容量与扩容"><a href="#HashMap的容量与扩容" class="headerlink" title="HashMap的容量与扩容"></a>HashMap的容量与扩容</h3><p><code>HashMap</code>类中有以下主要成员变量：</p><ul><li><p>transient int size;</p><p>记录了Map中KV对的个数</p></li><li><p>loadFactor</p><p>装载因子，用来衡量<code>HashMap</code>满的程度。loadFactor的默认值为0.75f（<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>）。</p></li><li><p>int threshold;</p><p>临界值，当实际KV个数超过threshold时，<code>HashMap</code>会将容量扩容，threshold＝容量*装载因子</p></li><li><p>除了以上这些重要成员变量外，<code>HashMap</code>中还有一个和他们紧密相关的概念：capacity</p><p>容量，如果不指定，默认容量是16(<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>)</p></li></ul><p><code>HashMap</code>的容量为什么是2的整数倍：主要是可以使用按位与替代取模来提升hash的效率。</p><p><code>HashMap</code>的扩容条件是什么：<code>HashMap</code>的扩容条件就是当<code>HashMap</code>中的元素个数（size）超过临界值（threshold）时就会自动扩容。</p><p>在<code>HashMap</code>中，threshold &#x3D; loadFactor * capacity。</p><p>loadFactor是装载因子，表示<code>HashMap</code>满的程度，默认值为0.75f，</p><h3 id="HashMap中hash方法的原理"><a href="#HashMap中hash方法的原理" class="headerlink" title="HashMap中hash方法的原理"></a>HashMap中hash方法的原理</h3><p>hash方法的功能是根据Key来定位这个K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是个int类型的数组下标。先调用hashcode方法返回一个整数，然后在对这个数取模。基本原理就是这个，只不过，在具体实现上，由两个方法<code>int hash(Object k)</code>和<code>int indexFor(int h, int length)</code>来实现。</p><h4 id="HashMap-In-Java-7"><a href="#HashMap-In-Java-7" class="headerlink" title="HashMap In Java 7"></a>HashMap In Java 7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将Object转换成一个整型。</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hashSeed;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br><br>    h ^= k.hashCode();<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。</span><br>&#125;<br><span class="hljs-comment">//将hash生成的整型转换成链表数组中的下标。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java用位运算(&amp;)来代替取模运算(%)以提升效率，X % 2^n &#x3D; X &amp; (2^n – 1)，只要保证length的长度是<code>2^n</code>的话，就可以实现取模运算了。</p><h4 id="HashTable-In-Java-7"><a href="#HashTable-In-Java-7" class="headerlink" title="HashTable In Java 7"></a>HashTable In Java 7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-comment">// hashSeed will be zero if alternative hashing is disabled.</span><br>    <span class="hljs-keyword">return</span> hashSeed ^ k.hashCode();<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于只是对k做了个简单的hash，取了一下其hashCode。而HashTable中也没有indexOf方法，取而代之的是这段代码：int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;。也就是说，HashMap和HashTable对于计算数组下标这件事，采用了两种方法。HashMap采用的是位运算，而HashTable采用的是直接取模。</p><ul><li>HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</li><li>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</li></ul><h4 id="HashMap-In-Java-8"><a href="#HashMap-In-Java-8" class="headerlink" title="HashMap In Java 8"></a>HashMap In Java 8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 8中的hash函数，原理和Java 7中基本类似。Java 8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理是不变的。</p><p>以上方法得到的int的hash值，然后再通过h &amp; (table.length -1)来得到该对象在数据中保存的位置。</p><h4 id="HashTable-In-Java-8"><a href="#HashTable-In-Java-8" class="headerlink" title="HashTable In Java 8"></a>HashTable In Java 8</h4><p>在Java 8的HashTable中，已经不再有hash方法了。但是哈希的操作还是在的，比如在put方法中就有如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br><br></code></pre></td></tr></table></figure><p>与java7中区别不大。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合类</title>
    <link href="/java-ji-he-lei/"/>
    <url>/java-ji-he-lei/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658821530/zhaoxu%60s%20blog/2022/1fdd90964ee659bd3a1b83018d2c59bb.png" alt="集合"></p><h2 id="Set和List区别？"><a href="#Set和List区别？" class="headerlink" title="Set和List区别？"></a>Set和List区别？</h2><p><code>List</code>,<code>Set</code>都是继承自<code>Collection</code>接口。都是用来存储一组相同类型的元素的。</p><p><code>List</code>特点：元素有放入顺序，元素可重复 。</p><p><code>Set</code>特点：元素无放入顺序，元素不可重复。</p><h2 id="ArrayList和LinkedList和Vector的区别？"><a href="#ArrayList和LinkedList和Vector的区别？" class="headerlink" title="ArrayList和LinkedList和Vector的区别？"></a>ArrayList和LinkedList和Vector的区别？</h2><p>三者都实现了<code>List </code>接口，</p><p><code>ArrayList </code>是一个可改变大小的数组.当更多的元素加入到<code>ArrayList </code>中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问。</p><p><code>Vector</code> 和<code>ArrayList </code>类似,但属于强同步类，多线程下安全。</p><p><code>LinkedList</code> 是一个双链表,在添加和删除元素时具有比<code>ArrayList </code>更好的性能.但在get与set方面弱于<code>ArrayList </code>.</p><p><code>Vector</code>和<code>ArrayList </code>在更多元素添加进来时会请求更大的空间。<code>Vector</code>每次请求其大小的双倍空间，而<code>ArrayList </code>每次对size增长50%。</p><p>而 <code>LinkedList </code>还实现了<code>Queue</code>接口,该接口比<code>List</code>提供了更多的方法,包括 offer(),peek(),poll()等。</p><h2 id="SynchronizedList和Vector的区别？"><a href="#SynchronizedList和Vector的区别？" class="headerlink" title="SynchronizedList和Vector的区别？"></a>SynchronizedList和Vector的区别？</h2><p><code>Vector</code>是java.util包中的一个类。 <code>SynchronizedList</code>是java.util.Collections中的一个静态内部类。</p><p>在多线程的场景中可以直接使用<code>Vector</code>类，也可以使用Collections.SynchronizedList(List list)方法来返回一个线程安全的<code>List</code>。</p><p><code>Vector</code>使用同步方法实现，<code>SynchronizedList</code>使用同步代码块实现。 2.两者的扩充数组容量方式不一样（两者的add方法在扩容方面的差别也就是<code>ArrayList</code>和<code>Vector</code>的差别。）</p><p><code>SynchronizedList</code>中实现的类并没有都使用synchronized同步代码块。其中有listIterator和listIterator(int index)并没有做同步处理。</p><p><code>SynchronizedList</code>和<code>Vector</code>最主要的区别： </p><p>1.<code>SynchronizedList</code>有很好的扩展和兼容功能。他可以将所有的<code>List</code>的子类转成线程安全的类。</p><p>2.使用<code>SynchronizedList</code>的时候，进行遍历时要手动进行同步处理。 </p><p>3.<code>SynchronizedList</code>可以指定锁定的对象。</p><h2 id="Set如何保证元素不重复"><a href="#Set如何保证元素不重复" class="headerlink" title="Set如何保证元素不重复?"></a>Set如何保证元素不重复?</h2><p>在Java的Set体系中，根据实现方式不同主要分为两大类。<code>HashSet</code>和<code>TreeSet</code>。</p><p>1、<code>TreeSet </code>是二叉树实现的，<code>TreeSet</code>中的数据是自动排好序的，不允许放入 null值<br>2、<code>HashSet</code> 是哈希表实现的，<code>HashSet</code>中的数据是无序的，可以放入 null值，但只能放入一个null，两者中的值都不能重复，就如数据库中的唯一约束</p><p>在<code>HashSet</code>中，基本的操作都是由<code>HashMap</code>底层实现的，因为<code>HashSet</code>底层是用<code>HashMap</code>存储数据的。当向<code>HashSet</code>中添加元素的时候，首先计算元素的hashCode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置为空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p><code>TreeSet</code>的底层是<code>TreeMap</code>的keySet()，而<code>TreeMap</code>是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p><code>TreeMap</code>是按key排序的，元素在插入<code>TreeSet</code>时compareTo()方法要被调用，所以<code>TreeSet</code>中的元素要实现<code>Comparable</code>接口。<code>TreeSet</code>作为一种Set，它不允许出现重复元素。<code>TreeSet</code>是用compareTo()来判断重复元素的。</p><h2 id="HashMap、HashTable、ConcurrentHashMap区别"><a href="#HashMap、HashTable、ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable、ConcurrentHashMap区别"></a>HashMap、HashTable、ConcurrentHashMap区别</h2><h3 id="HashMap和HashTable有何不同？"><a href="#HashMap和HashTable有何不同？" class="headerlink" title="HashMap和HashTable有何不同？"></a>HashMap和HashTable有何不同？</h3><p><strong>线程安全</strong>：<code>HashTable</code> 中的方法是同步的，而<code>HashMap</code>中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用<code>HashTable</code>，但是要使用<code>HashMap</code>的话就要自己增加同步处理了。</p><p><strong>继承关系</strong>： <code>HashTable</code>是基于陈旧的Dictionary类继承来的。 <code>HashMap</code>继承的抽象类AbstractMap实现了Map接口。</p><p><strong>允不允许null值</strong>： <code>HashTable</code>中，key和value都不允许出现null值，否则会抛出NullPointerException异常。 <code>HashMap</code>中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p><p><strong>默认初始容量和扩容机制</strong>： <code>HashTable</code>中的hash数组初始大小是11，增加的方式是 old*2+1。<code>HashMap</code>中hash数组的默认大小是16，而且一定是2的指数。</p><p><strong>哈希值的使用不同</strong> ： <code>HashTable</code>直接使用对象的hashCode。 <code>HashMap</code>重新计算hash值。</p><p><strong>遍历方式的内部实现上不同</strong> ： <code>HashTable</code>、<code>HashMap</code>都使用了 Iterator。而由于历史原因，<code>HashTable</code>还使用了Enumeration的方式 。 <code>HashMap</code> 实现 Iterator，支持fast-fail，<code>Hashtable</code>的 Iterator 遍历支持fast-fail，用 Enumeration 不支持 fast-fail。</p><h3 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h3><p><code>ConcurrentHashMap</code>和<code>HashMap</code>的实现方式不一样，虽然都是使用桶数组实现的，但是还是有区别，<code>ConcurrentHashMap</code>对桶数组进行了分段，而<code>HashMap</code>并没有。</p><p><code>ConcurrentHashMap</code>在每一个分段上都用锁进行了保护。<code>HashMap</code>没有锁机制。所以，前者线程安全的，后者不是线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题3</title>
    <link href="/leetcode-suan-fa-ti-3/"/>
    <url>/leetcode-suan-fa-ti-3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p><strong>题目</strong>：给你一个 无重复元素 的整数数组<code>candidates</code>和一个目标整数  <code>target</code>，找出<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p><code>candidates</code> 中的同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为  <code>target</code>  的不同组合数少于 150 个。</p><p><strong>示例</strong>：</p><blockquote><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7</p><p>输出：[[2,2,3],[7]]</p></blockquote><p><strong>思路</strong>：回溯的入门级题目，一般回溯的关键都是在于怎么去重。对于这道题，核心在于每次搜索的时候设置下一轮的搜索起点index。由于元素可以重复使用，所以对于同一根节点的节点我们可以重复的遍历，也就是调用第21行，我们可以继续用i作为下层遍历的开始，但对于同一层的节点我们就不能重复使用了，表现在代码上就是第19行，每次都遍历下个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(candidates);<br>    backTrack(candidates,target,re,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,List&lt;Integer&gt; re,<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index;i &lt; candidates.length;i++)&#123;<br>        re.add(candidates[i]);<br>        backTrack(candidates,target-candidates[i],re,i);<br>        re.remove(re.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p><strong>题目</strong>：给定一个候选人编号的集合 <code>candidates</code> 和一个目标数  <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code>的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p><p><strong>示例</strong>：</p><blockquote><p>输入：candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</p><p>输出：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>思路</strong>：与上题思路类似，关键点在于第21行的判断，这个判断的作用是，让同一层级不出现相同的元素，还允许不同层级之间的重复。在一个<code>for</code>循环中所有遍历到的都属于一个层级，所以<code>candidates[i]==candidates[i-1]</code>就限制了同一层级的重复，而<code>i&gt;index</code>则保证了不同层级的重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br>List&lt;Integer&gt; re;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(candidates);<br>    backTrack(<span class="hljs-number">0</span>,candidates,target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index;i &lt; candidates.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        re.add(candidates[i]);<br>        backTrack(i+<span class="hljs-number">1</span>,candidates,target-candidates[i]);<br>        re.remove(re.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p><strong>题目</strong>：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658818290/zhaoxu%60s%20blog/2022/9daebb6ebbdb925763fbd31e9a7aa329.jpg" alt="盛水最多的容器" title="盛水最多的容器"></p><p><strong>示例</strong>：</p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]</p><p>输出：49</p></blockquote><p><strong>思路</strong>：贪心思想，双指针从两边往中间遍历数组，每次只移动值较小的指针，然后计算并保存最大的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = height.length-<span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>        res = Math.max(res,Math.min(height[l],height[r])*(r-l));<br>        <span class="hljs-keyword">if</span>(height[l]&lt;height[r])&#123;<br>            l++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的各种关键字</title>
    <link href="/java-zhong-de-ge-chong-guan-jian-zi/"/>
    <url>/java-zhong-de-ge-chong-guan-jian-zi/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>用于修饰变量，被其修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>java的一个二元操作符，类似于&#x3D;&#x3D;，&gt;，&lt;等操作符，用于判断其左边的对象是否是其右边的类是实例。返回boolean类型。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>用于java多线程，只能用来修饰变量。</p><p><strong>可见性</strong>：被<code>volatile</code>修饰的变量，在被修改后会立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p><strong>有序性</strong>：被<code>volatile</code>修饰的变量，会严格按照代码顺序执行，禁止指令重排。</p><p><strong>原子性</strong>：<code>volatile</code>并不保证原子性，在以下两个场景中可以使用<code>volatile</code>来代替<code>synchronized</code>：</p><blockquote><p>1、运算结果并不依赖变量的当前值、</p><p>2、变量不需要与其他状态变量共同参与不变约束。</p></blockquote><p><strong>原理</strong>：处理器和内存之间存在多级缓存，但在多线程的情况下，会存在缓存一致性问题。如果一个变量被<code>volatile</code>所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个<code>volatile</code>在并发编程中，其值在多个缓存中是可见的。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>既可以修饰方法也可以修饰代码块</p><blockquote><p>同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。</p><p>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。</p><p>每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。</p></blockquote><p>无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。</p><p>ObjectMonitor类中提供了几个方法，如<code>enter</code>、<code>exit</code>、<code>wait</code>、<code>notify</code>、<code>notifyAll</code>等。<code>sychronized</code>加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。</p><p><strong>可见性</strong>：被<code>synchronized</code>修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p><p>所以，synchronized关键字锁住的对象，其值是具有可见性的。</p><p><strong>有序性</strong>：<code>synchronized</code>是无法禁止指令重排和处理器优化的，但他可以保证同一时间只有一个线程可以访问被其修饰的资源，相当于单线程执行，所以可以保证有序性。</p><p><strong>原子性</strong>：和有序性一样，由于<code>synchronized</code>保证了其修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。所以可以保证原子性。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final是Java中的一个关键字，它所表示的是“这部分是无法修改的”。</p><p>使用 final 可以定义 ：变量、方法、类。</p><p><strong>变量</strong>：如果将变量设置为final，则不能更改final变量的值(它将是常量)。</p><p><strong>方法</strong>：如果任何方法声明为final，则不能覆盖它。</p><p><strong>类</strong>：如果把任何一个类声明为final，则不能继承它。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static用来修饰成员变量和成员方法，也可以形成静态static代码块</p><p><strong>静态变量</strong>：一个类中的静态变量，不属于类的对象或者实例。因为静态变量与所有的对象实例共享，因此他们不具线程安全性。</p><p>通常，静态变量常用final关键来修饰，表示通用资源或可以被所有的对象所使用。</p><p><strong>静态方法</strong>：与静态变量一样，静态方法是属于类而不是实例。</p><p>一个静态方法只能使用静态变量和调用静态方法。通常静态方法通常用于想给其他的类使用而不需要创建实例。</p><p><strong>静态代码块</strong>：Java的静态块是一组指令在类装载的时候在内存中由Java ClassLoader执行。</p><p>静态块常用于初始化类的静态变量。大多时候还用于在类装载时候创建静态资源。</p><p>Java不允许在静态块中使用非静态变量。一个类中可以有多个静态块。静态块只在类装载入内存时，执行一次。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const是Java预留关键字，用于后期扩展用，用法跟final相似，不常用</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题2</title>
    <link href="/leetcode-suan-fa-ti-2/"/>
    <url>/leetcode-suan-fa-ti-2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="剑指Offer51-数组中的逆序对"><a href="#剑指Offer51-数组中的逆序对" class="headerlink" title="剑指Offer51.数组中的逆序对"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指Offer51.数组中的逆序对</a></h2><p><strong>题目</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例</strong>：</p><blockquote><p>输入：[7,5,6,4]</p><p>输出：5</p></blockquote><p><strong>思路</strong>：一眼暴力超时，然后想着能不能用单调栈。发现也不行，单调栈只能得到一个数左右两边第一个比它大或小的数，不能解决本体，所以只能看答案了，毕竟是道困难题。结果答案用归并排序，这是我怎么都想不到的，只用在归并排序中加一行代码就能解决这道题，关键在于归并中并的过程，合并的时候能很容易的计算出一个数的前面有多少个比它大的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    sort(nums,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len]);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left&gt;=right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+((right-left)&gt;&gt;<span class="hljs-number">1</span>);<br>    sort(nums,left,mid,temp);<br>    sort(nums,mid+<span class="hljs-number">1</span>,right,temp);<br>    merge(nums,left,right,temp);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left,mid = left+((right-left)&gt;&gt;<span class="hljs-number">1</span>),j = mid+<span class="hljs-number">1</span>,cur = left;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&lt;=nums[j])&#123;<br>            temp[cur++] = nums[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            count+=(mid-i+<span class="hljs-number">1</span>);<br>            temp[cur++] = nums[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>        temp[cur++] = nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=right)&#123;<br>        temp[cur++] = nums[j++];<br>    &#125;<br>    cur = left;<br>    <span class="hljs-keyword">while</span>(cur&lt;=right)&#123;<br>        nums[cur] = temp[cur];<br>        cur++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-077-链表排序"><a href="#剑指-Offer-II-077-链表排序" class="headerlink" title="剑指 Offer II 077. 链表排序"></a><a href="https://leetcode.cn/problems/7WHec2/">剑指 Offer II 077. 链表排序</a></h2><p><strong>题目</strong>：给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658731598/zhaoxu%60s%20blog/2022/ef6fb1f39c8b265b7bfb4170bbae8866.jpg" alt="链表排序" title="链表排序"></p><p><strong>思路</strong>：复习上一道题的归并排序，一道链表的归并排序题。关键点在于10和11行的断尾操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">return</span> sort(head,<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode head,ListNode tail)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head.next==tail)&#123;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head,fast = slow;<br>    <span class="hljs-keyword">while</span>(fast!=tail&amp;&amp;fast.next!=tail)&#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> sort(head,slow);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> sort(slow,tail);<br>    <span class="hljs-keyword">return</span> meger(first,second);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">meger</span><span class="hljs-params">(ListNode first,ListNode second)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>),cur = dummyHead;<br>    <span class="hljs-keyword">while</span>(first!=<span class="hljs-literal">null</span>&amp;&amp;second!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(first.val&lt;=second.val)&#123;<br>            cur.next = first;<br>            first = first.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur.next = second;<br>            second = second.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(first!=<span class="hljs-literal">null</span>)&#123;<br>        cur.next = first;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(second!=<span class="hljs-literal">null</span>)&#123;<br>        cur.next = second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo个人博客搭建1</title>
    <link href="/hexo-ge-ren-bo-ke-da-jian-1/"/>
    <url>/hexo-ge-ren-bo-ke-da-jian-1/</url>
    
    <content type="html"><![CDATA[<p>简略介绍一下本博客的搭建过程，如果你也想搭建博客的话，也算是提供一种思路。详细的教程就不写了。</p><span id="more"></span><h1 id="Hexo-Github搭建博客网站介绍"><a href="#Hexo-Github搭建博客网站介绍" class="headerlink" title="Hexo+Github搭建博客网站介绍"></a>Hexo+Github搭建博客网站介绍</h1><p>本来想详细写写我怎么搭建这个网站的，想了想还是算了，毕竟网上有好多比较好的教程了。那就把我搭建也是学习的过程说明一下，也方便以后我对其进行维护。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658820351/zhaoxu%60s%20blog/2022/bfd790f1ac4d0dc1d9e098f8b0727d3c.png" alt="Hexo+GitHub"></p><h2 id="1-Hexo建立网站"><a href="#1-Hexo建立网站" class="headerlink" title="1.Hexo建立网站"></a>1.Hexo建立网站</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658664215/zhaoxu%60s%20blog/2022/6890485c84748900d9dae824b7f7cbb1.png" alt="hexo" title="hexo" style="zoom: 50%;" /></div><br/><p>一个快速、简洁且高效的博客框架，使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页，具体的安装过程可以在<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>进行查阅。</p><h2 id="2-GitHub托管代码"><a href="#2-GitHub托管代码" class="headerlink" title="2.GitHub托管代码"></a>2.GitHub托管代码</h2><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669169/zhaoxu%60s%20blog/2022/6a7440baee823b7f5ab73a15071826a9.png" alt="GitHub Pages" title="GitHub Pages"></p><p>利用hexo生成博客的代码后，我们还需要发布网站，让我们的网站可以被别人访问。而GItHub page则允许我们免费使用，将我们的页面展示到互联网。具体的使用可参阅<a href="https://docs.github.com/cn/pages/getting-started-with-github-pages">Github page官网</a>。</p><p>github和hexo怎么结合使用的详细过程可以参阅知乎的这篇<a href="https://zhuanlan.zhihu.com/p/26625249">文章</a>。</p><h2 id="3-Fluid主题的使用"><a href="#3-Fluid主题的使用" class="headerlink" title="3.Fluid主题的使用"></a>3.Fluid主题的使用</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669257/zhaoxu%60s%20blog/2022/6b0cfa7891dbcc1a7da696be94581113.png" alt="Fluid" title="Fluid" style="zoom:50%;" /></div><p>如果只使用hexo的原版页面也不是不能写博客，不过hexo的<a href="https://hexo.io/themes/">主题市场</a>提供了很多五花八门的主题供我们选择。我选择了<a href="https://hexo.fluid-dev.com/docs/start/">fluid</a>这款主题，主要是该主题的文档是中文的，而且尤其的详细，简直是萌新之友。</p><div align="left"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669294/zhaoxu%60s%20blog/2022/4296b26c8971fe4d12a1e24f9fb98719.png" alt="fluid的配置指南" title="fluid的配置指南" style="zoom:80%;" /></div><br/><p>通过这篇文档还学到很多主题的玩法，真的受益匪浅。</p><h2 id="4-Waline评论功能集成"><a href="#4-Waline评论功能集成" class="headerlink" title="4.Waline评论功能集成"></a>4.Waline评论功能集成</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658670164/zhaoxu%60s%20blog/2022/f17008f4d71403caac8c37a7dd66061e.png" alt="image-20220724214242749" style="zoom:50%;" /></div><br/><p>通过阅读fluid的文档了解到其很好的集成了各种各样的评论功能，然后就选择了Waline作为该博客的评论系统。也是对着<a href="https://waline.js.org/guide/get-started.html">Waline</a>的文档进行一步一步的配置，没什么特别的。</p><h2 id="5-LeanCloud设置-数据库"><a href="#5-LeanCloud设置-数据库" class="headerlink" title="5.LeanCloud设置(数据库)"></a>5.LeanCloud设置(数据库)</h2><p>Waline评论系统的数据库，也可以用来统计网站的PV与UV数据，主要是fluid都集成好了，不需要进行太多的配置就能使用。<a href="https://console.leancloud.app/apps">LeanCloud官网</a></p><h2 id="6-Vercel部署-服务端"><a href="#6-Vercel部署-服务端" class="headerlink" title="6.Vercel部署(服务端)"></a>6.Vercel部署(服务端)</h2><p>Waline评论系统的服务端，后面我发现也可以用来部署博客，还是完全免费的。简直不要太好用。<a href="https://vercel.com/dashboard">Vercel官网</a></p><p>以上就是我部署该博客网站的过程了，该文章并不算是一个教程，主要是用来记录一下。谢谢你的阅读。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题1</title>
    <link href="/leetcode-suan-fa-ti-1/"/>
    <url>/leetcode-suan-fa-ti-1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112.路径总和</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658456820/zhaoxu%60s%20blog/2022/zvmf91dubran2qviuwlr.jpg" alt="二叉树" title="二叉树"></p><p><strong>思路</strong>：一道简单题，没有什么好说的，递归深搜就完事了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> root.val==targetSum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.right,targetSum-root.val)||hasPathSum(root.left,targetSum-root.val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113.路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和 II</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658584569/zhaoxu%60s%20blog/2022/1a579f9ff7f6c496afe1e6e82e94aef8.jpg" alt="二叉树2" title="二叉树2"></p><p><strong>思路</strong>：与上题类似，不同的是这个要返回路径。一道基本的回溯题，关键在于什么时候回溯，将添加放在加入结果集的前面，然后不用返回，这样就可以把最后进入结果集的节点删除。这是关键，原来写过类似的，加深下印象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    List&lt;Integer&gt; re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backTrack(root,targetSum,re);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> targetSum,List&lt;Integer&gt; re)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    re.add(root.val);<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.val==targetSum)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>    &#125;<br>    backTrack(root.left,targetSum-root.val,re);<br>    backTrack(root.right,targetSum-root.val,re);<br>    re.remove(re.size()-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径求和-III"><a href="#437-路径求和-III" class="headerlink" title="437.路径求和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437.路径求和 III</a></h2><p><strong>题目</strong>：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658586638/zhaoxu%60s%20blog/2022/6bdf3a6b74f892a62ab38fcde3f9c147.jpg" alt="二叉树3" title="二叉树3"></p><p><strong>思路</strong>：与前面两道题不同，这道题的关键在于如何递归的处理并遍历整个树，使其不重复。看评论区这个操作叫双重递归，从每个节点开始进行类似的计算，用第一个递归用来遍历这些节点，第二个递归用来处理这些节点，进行深搜。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> pathSumWithRoot(root,targetSum)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSumWithRoot</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">long</span> targetSum)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root.val==targetSum)&#123;<br>        res++;<br>    &#125;<br>    res += pathSumWithRoot(root.left,targetSum-root.val);<br>    res += pathSumWithRoot(root.right,targetSum-root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first page</title>
    <link href="/my-first-page/"/>
    <url>/my-first-page/</url>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这篇博文主要用来学习markdown的基本语法</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>Java</li><li>C++</li><li>Python</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello world<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>后来我发现了Typora这个软件，实在是好用，才知道markdown根本不用学。</p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
