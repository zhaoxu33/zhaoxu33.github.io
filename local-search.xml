<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode刷题笔记2</title>
    <link href="/leetcode-shua-ti-bi-ji-2/"/>
    <url>/leetcode-shua-ti-bi-ji-2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="剑指Offer51-数组中的逆序对"><a href="#剑指Offer51-数组中的逆序对" class="headerlink" title="剑指Offer51.数组中的逆序对"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指Offer51.数组中的逆序对</a></h2><p><strong>题目</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>思路</strong>：一眼暴力超时，然后想着能不能用单调栈。发现也不行，单调栈只能得到一个数左右两边第一个比它大或小的数，不能解决本体，所以只能看答案了，毕竟是道困难题。结果答案用归并排序，这是我怎么都想不到的，只用在归并排序中加一行代码就能解决这道题，关键在于归并中并的过程，合并的时候能很容易的计算出一个数的前面有多少个比它大的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    sort(nums,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len]);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left&gt;=right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+((right-left)&gt;&gt;<span class="hljs-number">1</span>);<br>    sort(nums,left,mid,temp);<br>    sort(nums,mid+<span class="hljs-number">1</span>,right,temp);<br>    merge(nums,left,right,temp);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left,mid = left+((right-left)&gt;&gt;<span class="hljs-number">1</span>),j = mid+<span class="hljs-number">1</span>,cur = left;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&lt;=nums[j])&#123;<br>            temp[cur++] = nums[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            count+=(mid-i+<span class="hljs-number">1</span>);<br>            temp[cur++] = nums[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>        temp[cur++] = nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=right)&#123;<br>        temp[cur++] = nums[j++];<br>    &#125;<br>    cur = left;<br>    <span class="hljs-keyword">while</span>(cur&lt;=right)&#123;<br>        nums[cur] = temp[cur];<br>        cur++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-077-链表排序"><a href="#剑指-Offer-II-077-链表排序" class="headerlink" title="剑指 Offer II 077. 链表排序"></a><a href="https://leetcode.cn/problems/7WHec2/">剑指 Offer II 077. 链表排序</a></h2><p><strong>题目</strong>：给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658731598/zhaoxu%60s%20blog/2022/ef6fb1f39c8b265b7bfb4170bbae8866.jpg" alt="链表排序" title="链表排序"></p><p><strong>思路</strong>：复习上一道题的归并排序，一道链表的归并排序题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">return</span> sort(head,<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode head,ListNode tail)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head.next==tail)&#123;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head,fast = slow;<br>    <span class="hljs-keyword">while</span>(fast!=tail&amp;&amp;fast.next!=tail)&#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> sort(head,slow);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> sort(slow,tail);<br>    <span class="hljs-keyword">return</span> meger(first,second);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">meger</span><span class="hljs-params">(ListNode first,ListNode second)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>),cur = dummyHead;<br>    <span class="hljs-keyword">while</span>(first!=<span class="hljs-literal">null</span>&amp;&amp;second!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(first.val&lt;=second.val)&#123;<br>            cur.next = first;<br>            first = first.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur.next = second;<br>            second = second.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(first!=<span class="hljs-literal">null</span>)&#123;<br>        cur.next = first;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(second!=<span class="hljs-literal">null</span>)&#123;<br>        cur.next = second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo个人博客搭建1</title>
    <link href="/hexo-ge-ren-bo-ke-da-jian-1/"/>
    <url>/hexo-ge-ren-bo-ke-da-jian-1/</url>
    
    <content type="html"><![CDATA[<p>简略介绍一下本博客的搭建过程，如果你也想搭建博客的话，也算是提供一种思路。详细的教程就不写了。</p><span id="more"></span><h1 id="Hexo-Github搭建博客网站介绍"><a href="#Hexo-Github搭建博客网站介绍" class="headerlink" title="Hexo+Github搭建博客网站介绍"></a>Hexo+Github搭建博客网站介绍</h1><p>本来想详细写写我怎么搭建这个网站的，想了想还是算了，毕竟网上有好多比较好的教程了。那就把我搭建也是学习的过程说明一下，也方便以后我对其进行维护。</p><h2 id="1-Hexo建立网站"><a href="#1-Hexo建立网站" class="headerlink" title="1.Hexo建立网站"></a>1.Hexo建立网站</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658664215/zhaoxu%60s%20blog/2022/6890485c84748900d9dae824b7f7cbb1.png" alt="hexo" title="hexo" style="zoom: 50%;" /></div><br/><p>一个快速、简洁且高效的博客框架，使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页，具体的安装过程可以在<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>进行查阅。</p><h2 id="2-GitHub托管代码"><a href="#2-GitHub托管代码" class="headerlink" title="2.GitHub托管代码"></a>2.GitHub托管代码</h2><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669169/zhaoxu%60s%20blog/2022/6a7440baee823b7f5ab73a15071826a9.png" alt="GitHub Pages" title="GitHub Pages"></p><p>利用hexo生成博客的代码后，我们还需要发布网站，让我们的网站可以被别人访问。而GItHub page则允许我们免费使用，将我们的页面展示到互联网。具体的使用可参阅<a href="https://docs.github.com/cn/pages/getting-started-with-github-pages">Github page官网</a>。</p><p>github和hexo怎么结合使用的详细过程可以参阅知乎的这篇<a href="https://zhuanlan.zhihu.com/p/26625249">文章</a>。</p><h2 id="3-Fluid主题的使用"><a href="#3-Fluid主题的使用" class="headerlink" title="3.Fluid主题的使用"></a>3.Fluid主题的使用</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669257/zhaoxu%60s%20blog/2022/6b0cfa7891dbcc1a7da696be94581113.png" alt="Fluid" title="Fluid" style="zoom:50%;" /></div><p>如果只使用hexo的原版页面也不是不能写博客，不过hexo的<a href="https://hexo.io/themes/">主题市场</a>提供了很多五花八门的主题供我们选择。我选择了<a href="https://hexo.fluid-dev.com/docs/start/">fluid</a>这款主题，主要是该主题的文档是中文的，而且尤其的详细，简直是萌新之友。</p><div align="left"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669294/zhaoxu%60s%20blog/2022/4296b26c8971fe4d12a1e24f9fb98719.png" alt="fluid的配置指南" title="fluid的配置指南" style="zoom:80%;" /></div><br/><p>通过这篇文档还学到很多主题的玩法，真的受益匪浅。</p><h2 id="4-Waline评论功能集成"><a href="#4-Waline评论功能集成" class="headerlink" title="4.Waline评论功能集成"></a>4.Waline评论功能集成</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658670164/zhaoxu%60s%20blog/2022/f17008f4d71403caac8c37a7dd66061e.png" alt="image-20220724214242749" style="zoom:50%;" /></div><br/><p>通过阅读fluid的文档了解到其很好的集成了各种各样的评论功能，然后就选择了Waline作为该博客的评论系统。也是对着<a href="https://waline.js.org/guide/get-started.html">Waline</a>的文档进行一步一步的配置，没什么特别的。</p><h2 id="5-LeanCloud设置-数据库"><a href="#5-LeanCloud设置-数据库" class="headerlink" title="5.LeanCloud设置(数据库)"></a>5.LeanCloud设置(数据库)</h2><p>Waline评论系统的数据库，也可以用来统计网站的PV与UV数据，主要是fluid都集成好了，不需要进行太多的配置就能使用。<a href="https://console.leancloud.app/apps">LeanCloud官网</a></p><h2 id="6-Vercel部署-服务端"><a href="#6-Vercel部署-服务端" class="headerlink" title="6.Vercel部署(服务端)"></a>6.Vercel部署(服务端)</h2><p>Waline评论系统的服务端，后面我发现也可以用来部署博客，还是完全免费的。简直不要太好用。<a href="https://vercel.com/dashboard">Vercel官网</a></p><p>以上就是我部署该博客网站的过程了，该文章并不算是一个教程，主要是用来记录一下。谢谢你的阅读。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题日记1</title>
    <link href="/leetcode-shua-ti-ri-ji-1/"/>
    <url>/leetcode-shua-ti-ri-ji-1/</url>
    
    <content type="html"><![CDATA[<p>几道二叉树的路径求和题，原来写过，现在又忘了，果然刷题只有重复、重复、再重复！</p><span id="more"></span><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112.路径总和</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658456820/zhaoxu%60s%20blog/2022/zvmf91dubran2qviuwlr.jpg" alt="二叉树" title="二叉树"></p><p><strong>思路</strong>：一道简单题，没有什么好说的，递归深搜就完事了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> root.val==targetSum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.right,targetSum-root.val)||hasPathSum(root.left,targetSum-root.val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113.路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和 II</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658584569/zhaoxu%60s%20blog/2022/1a579f9ff7f6c496afe1e6e82e94aef8.jpg" alt="二叉树2" title="二叉树2"></p><p><strong>思路</strong>：与上题类似，不同的是这个要返回路径。一道基本的回溯题，关键在于什么时候回溯，将添加放在加入结果集的前面，然后不用返回，这样就可以把最后进入结果集的节点删除。这是关键，原来写过类似的，加深下印象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    List&lt;Integer&gt; re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backTrack(root,targetSum,re);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> targetSum,List&lt;Integer&gt; re)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    re.add(root.val);<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.val==targetSum)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>    &#125;<br>    backTrack(root.left,targetSum-root.val,re);<br>    backTrack(root.right,targetSum-root.val,re);<br>    re.remove(re.size()-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径求和-III"><a href="#437-路径求和-III" class="headerlink" title="437.路径求和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437.路径求和 III</a></h2><p><strong>题目</strong>：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658586638/zhaoxu%60s%20blog/2022/6bdf3a6b74f892a62ab38fcde3f9c147.jpg" alt="二叉树3" title="二叉树3"></p><p><strong>思路</strong>：与前面两道题不同，这道题的关键在于如何递归的处理并遍历整个树，使其不重复。看评论区这个操作叫双重递归，从每个节点开始进行类似的计算，用第一个递归用来遍历这些节点，第二个递归用来处理这些节点，进行深搜。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> pathSumWithRoot(root,targetSum)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSumWithRoot</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">long</span> targetSum)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root.val==targetSum)&#123;<br>        res++;<br>    &#125;<br>    res += pathSumWithRoot(root.left,targetSum-root.val);<br>    res += pathSumWithRoot(root.right,targetSum-root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first page</title>
    <link href="/my-first-page/"/>
    <url>/my-first-page/</url>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这篇博文主要用来学习markdown的基本语法</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>Java</li><li>C++</li><li>Python</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello world<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>后来我发现了Typora这个软件，实在是好用，才发现原来markdown根本不用学。</p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
