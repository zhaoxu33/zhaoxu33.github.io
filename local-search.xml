<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis数据结构</title>
    <link href="/redis-shu-ju-jie-gou/"/>
    <url>/redis-shu-ju-jie-gou/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="Redis数据类型及使用场景"><a href="#Redis数据类型及使用场景" class="headerlink" title="Redis数据类型及使用场景"></a>Redis数据类型及使用场景</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）</strong>。</p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作;对整数或浮点数进行自增或自减操作</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除;还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。 Redis 五种数据类型的应用场景：</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><h3 id="Redis数据类型的实现方式"><a href="#Redis数据类型的实现方式" class="headerlink" title="Redis数据类型的实现方式"></a>Redis数据类型的实现方式</h3><table><thead><tr><th>数据类型</th><th>实现方式</th></tr></thead><tbody><tr><td>String 类型</td><td>SDS</td></tr><tr><td>List 类型</td><td>压缩列表或双向链表（3.2之后，quicklist ）</td></tr><tr><td>Hash 类型</td><td>压缩列表或哈希表（7.0之后，压缩列表废弃，改为listpack）</td></tr><tr><td>Set 类型</td><td>整数集合或哈希表</td></tr><tr><td>ZSet 类型</td><td>压缩列表或跳表（7.0之后，压缩列表废弃，改为listpack）</td></tr></tbody></table><h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><p>String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p><ul><li>SDS 不仅可以保存文本数据，还可以保存二进制数据。</li><li>SDS 获取字符串长度的时间复杂度是 O(1)</li><li>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</li></ul><h4 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h4><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p><strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p><h4 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h4><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><h4 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h4><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h4 id="ZSet-类型"><a href="#ZSet-类型" class="headerlink" title="ZSet 类型"></a>ZSet 类型</h4><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/mysql-suo-yin/"/>
    <url>/mysql-suo-yin/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>索引是存储引擎用于快速查找记录的一种数据结构。</p><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>当谈论索引的时候，如果没有特别的指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据结构。大多数MySQL引擎都支持这种索引。</p><p>存储引擎以不同的方式使用B-Tree索引，性能也各不相同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1660014893/zhaoxu%60s%20blog/2022/2c705cda4ee24a0ef192522f26304556.png" alt="建立在B-Tree结构上索引"></p><p><strong>可以使用B-Tree索引的查询类型:</strong></p><p>B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。</p><p><strong>B-Tree索引的限制：</strong></p><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引。</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ul><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p>哈希表的索引自身只存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度十分快，但也有其限制：</p><ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li><li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li><li>哈希索引只支持等值比较查询，不支持任何范围查询。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突。当哈希冲突出现时，存储引擎必须遍历链表中所有的行指针，并逐行比较。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</li></ul><p>在MySQL中，只有Memory引擎显示支持哈希索引。这是其默认索引类型，同时其也支持B-Tree索引。同时它还支持非唯一哈希索引，如果多个列哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。InnoDB引擎中有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引。</p><h4 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h4><p>MyISAM表支持空间索引，可以用于地理数据存储。和B-Tree索引不同，这类索引无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引总的值。</p><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>索引可以让服务器快速地定位到表的指定位置。</p><p>最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：</p><ol><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机I&#x2F;O变为顺序I&#x2F;O。</li></ol><h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>”独立的列“是指索引列不能是表达式的一部分，也不能是函数的参数。</p><p>例如，下面的这个查询无法使用actor_id列的索引：</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1660030718/zhaoxu%60s%20blog/2022/386e88eb56098efffc8dc15e58322a6f.png" alt="mysql语句1"></p><p>MySQL无法自动解析这个方程式。我们应该养成简化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧。</p><h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p><p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。所以关键在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。</p><p>为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>一个常见的错误是，为每个列创建独立额索引，或者按照错误的顺序创建多列索引。</p><p>然而，在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p><h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和 DISTINCT等子句的查询需求。</p><p>对于如何选择索引的列顺序有一个经验法则:将选择性最高的列放到索引最前列。这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机IO和排序那么重要，考虑问题需要更全面(场景不同则选择不同，没有一个放之四海皆准的法则。这里只是说明，这个经验法则可能没有你想象的重要)。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p><p>当表有聚簇索引时,它的数据行实际上存放在索引的叶子页(leaf page)中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方,所以一个表只能有一个聚簇索引(不过,覆盖索引可以模拟多个聚簇索引的情况)。</p><p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中，索引列包含的是整数值。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1660034223/zhaoxu%60s%20blog/2022/d2668b9890aa0f7419d78a6fbf9b20c6.png" alt="聚簇索引的数据分布"></p><p>聚簇主键可能对性能有帮助，但也可能导致严重的性能问题。所以需要仔细地考虑聚簇索引，尤其是将表的存储引擎从InnoDB改成其他引擎的时候（反过来也一样)。</p><p>聚集的数据有一些重要的优点:</p><ul><li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘IO。</li><li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ul><p>如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点:</p><ul><li>聚簇数据最大限度地提高了I&#x2F;O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li><li>插人速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。</li><li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li><li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂(page split)”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li><li>二级索引访问需要两次索引查找，而不是一次。</li></ul><h4 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h4><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1660047339/zhaoxu%60s%20blog/2022/570af732e6fe600f3e8dffa2558fbe7f.png" alt="聚簇和非聚簇表对比图"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL锁问题</title>
    <link href="/mysql-suo-wen-ti/"/>
    <url>/mysql-suo-wen-ti/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="MySQL锁概述"><a href="#MySQL锁概述" class="headerlink" title="MySQL锁概述"></a>MySQL锁概述</h2><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p>行级锁：开销大，加锁慢；会出现死锁；锁的粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><h2 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h2><h3 id="MySQL表级锁的锁模式"><a href="#MySQL表级锁的锁模式" class="headerlink" title="MySQL表级锁的锁模式"></a>MySQL表级锁的锁模式</h3><p>MySQL的表级锁有两种模式：表共享读锁和表独占写锁。锁模式的兼容性如下图<img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659690775/zhaoxu%60s%20blog/2022/b2f88a6acd5db790e39939725890be2e.png" alt="MySQL中表锁兼容性"></p><p>可见对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写请求；MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</p><h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><p>MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁。</p><h3 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h3><p>MyISAM表的读和写是串行的，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行。MyISAM存储引擎有一个系统变量concurrent_insert,专门用以控制其并发插入的行为，其值分别可以为0,1或2.</p><ul><li>当concurrent_insert为0时，不允许并发插入。</li><li>当concurrent_insert为1时，如果MyISAM表中没有空间（即表中没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录，这是其默认设置</li><li>当concurrent_insert为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li></ul><h3 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h3><p>MySQL认为写请求一般比读请求重要，所以在写请求和读请求同时到来时，会优先处理写请求，即使读请求先到锁等待队列，写请求后到，写锁也会插入到读锁之前。可以通过一些设置来调节MyISAM的调度行为。</p><ul><li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利</li><li>通过执行命令SET LOW_PRIORITY_UPDATES&#x3D;1,使该连接发出的更新请求优先级降低</li><li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级</li></ul><h2 id="InooDB锁问题"><a href="#InooDB锁问题" class="headerlink" title="InooDB锁问题"></a>InooDB锁问题</h2><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="1-事务及其ACID属性"><a href="#1-事务及其ACID属性" class="headerlink" title="1.事务及其ACID属性"></a>1.事务及其ACID属性</h4><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659794092/zhaoxu%60s%20blog/2022/6ed1f84e404144939d216377e4005d3c.png" alt="ACID属性"></p><h4 id="2-并发事务处理带来的问题"><a href="#2-并发事务处理带来的问题" class="headerlink" title="2.并发事务处理带来的问题"></a>2.并发事务处理带来的问题</h4><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659794172/zhaoxu%60s%20blog/2022/571361ada7dee5378584aee9dd7b9e90.png" alt="并发事务问题"></p><h4 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h4><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659794245/zhaoxu%60s%20blog/2022/b5b61494ec3ac3740911ea162850653c.png" alt="事务隔离级别"></p><h3 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h3><p>InnoDB实现了以下两种类型的行锁</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排它锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享锁和排他锁。</li></ul><p>另外为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先得到该标的IX锁。</li></ul><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659794750/zhaoxu%60s%20blog/2022/6b241e2f725ce43d21644b84d23cc59e.png" alt="锁兼容性"></p><p>如果一个事务的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p>意向锁是InnoDB自动加的，不需要用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X）；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><ul><li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</li><li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE。</li></ul><h3 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h3><p>InnoDB行锁是通过给索引上索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁。InnoDB行锁分为3种情形。</p><ul><li>Record lock：对索引项加锁。</li><li>Gap lock：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁。</li><li>Next-key lock:前两种的结合，对记录及其前面的间隙加锁。</li></ul><p>这意味着：如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果和表锁是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题8</title>
    <link href="/leetcode-suan-fa-ti-8/"/>
    <url>/leetcode-suan-fa-ti-8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146. LRU缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU缓存</a></h2><p><strong>题目</strong>：请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li></ul><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p><strong>示例</strong>：</p><blockquote><p>输入：[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</p><p>输出：[null, null, null, 1, null, -1, null, -1, 3, 4]</p></blockquote><p><strong>思路</strong>  ：使用双向链表和哈希表数据结构实现LRU。靠近头节点的位置为最近使用，靠近尾部的最久未使用。哈希表为普通的哈希映射，通过缓存数据的键映射到其所在双向链表中的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer,node&gt; hm;<br>node head;<br>node tail;<br><span class="hljs-type">int</span> capacity;<br><span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-built_in">this</span>.capacity = capacity;<br>    <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    head.next = tail;<br>    tail.pre = head;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span>(hm.containsKey(key))&#123;<br>        <span class="hljs-type">node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> hm.get(key);<br>        remove(cur);<br>        addhead(cur);<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span>(hm.containsKey(key))&#123;<br>        <span class="hljs-type">node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> hm.get(key);<br>        cur.val = value;<br>        remove(cur);<br>        addhead(cur);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">node</span>(key,value);<br>        addhead(cur);<br>        hm.put(key,cur);<br>        size++;<br>        <span class="hljs-keyword">if</span>(size&gt;capacity)&#123;<br>            <span class="hljs-type">node</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> removetail();<br>            hm.remove(n.key);<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(node cur)</span>&#123;<br>    cur.pre.next = cur.next;<br>    cur.next.pre = cur.pre;<br>    cur.pre = <span class="hljs-literal">null</span>;<br>    cur.next = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addhead</span><span class="hljs-params">(node cur)</span>&#123;<br>    cur.next = head.next;<br>    head.next.pre = cur;<br>    cur.pre = head;<br>    head.next = cur;<br>&#125;<br><br><span class="hljs-keyword">public</span> node <span class="hljs-title function_">removetail</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> tail.pre;<br>    remove(cur);<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> key;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">private</span> node pre;<br>    <span class="hljs-keyword">private</span> node next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val, node pre, node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.pre = pre;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记1</title>
    <link href="/mysql-xue-xi-bi-ji-1/"/>
    <url>/mysql-xue-xi-bi-ji-1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659323613/zhaoxu%60s%20blog/2022/7b0fb5ec866750a0807e7e1461535471.png" alt="MySQL逻辑架构图"></p><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h3><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。InnoDB 的 redo log 是固定大小的。</p><h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>MySQL 整体来看，有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面的粉板 redo log（重做日志）是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>这两种日志有以下三点不同。</p><ol><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>一条SQL更新语句的执行过程</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659359620/zhaoxu%60s%20blog/2022/f299f874f2b08a9b0b80b276daafe537.png" alt="update 语句"></p><p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题7</title>
    <link href="/leetcode-suan-fa-ti-7/"/>
    <url>/leetcode-suan-fa-ti-7/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h2><p><strong>题目</strong>：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1659149013/zhaoxu%60s%20blog/2022/ec0f6cde6f335ed28ebbb11449663bc8.jpg" alt="二叉树"></p><p><strong>示例</strong>：</p><blockquote><p>输入：root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]</p><p>输出：true</p></blockquote><p><strong>思路</strong>：双重递归，从每个节点开始进行类似的计算，用第一个递归用来遍历这些节点，第二个递归用来处理这些节点，进行深搜匹配子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isRootSubtree(root,subRoot)||isSubtree(root.left,subRoot)||isSubtree(root.right,subRoot);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRootSubtree</span><span class="hljs-params">(TreeNode root,TreeNode subRoot)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>&amp;&amp;subRoot==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||subRoot==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.val==subRoot.val)&#123;<br>        <span class="hljs-keyword">return</span> isRootSubtree(root.left,subRoot.left)&amp;&amp;isRootSubtree(root.right,subRoot.right);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><p><strong>题目</strong>：给你一个非负整数数组<code> nums</code> ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [2,3,1,1,4]</p><p>输出：2</p></blockquote><p><strong>思路</strong>1：错误方法，时间复杂度和空间复杂度都贼高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    Arrays.fill(dp,Integer.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.length&amp;&amp;j&lt;=i+nums[i])&#123;<br>            dp[j] = Math.min(dp[i]+<span class="hljs-number">1</span>,dp[j]);<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路</strong>2：正确方法，贪心思想。「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,temp = <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>        temp = Math.max(temp,i+nums[i]);<br>        <span class="hljs-keyword">if</span>(i==end)&#123;<br>            end = temp;<br>            result++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题6</title>
    <link href="/leetcode-suan-fa-ti-6/"/>
    <url>/leetcode-suan-fa-ti-6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2><p><strong>题目</strong>：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例</strong>：</p><blockquote><p>输入：prices &#x3D; [3,3,5,0,0,3,1,4]</p><p>输出：6</p></blockquote><p><strong>思路</strong>：动态规划。根据题意划分为4个状态，买一，卖一，买二，卖二。对数组进行遍历，同时对这个4个变量进行更新，最后返回卖2。其中第一天的起始状态为-prices[0],0,-prices[0],0。然后从i&#x3D;1开始进行动态规划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">buy1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,sell1 = <span class="hljs-number">0</span>,buy2 = <span class="hljs-number">0</span>,sell2 = <span class="hljs-number">0</span>,len = prices.length;<br>    <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>        buy1 = -prices[<span class="hljs-number">0</span>];<br>        buy2 = -prices[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; len;i++)&#123;<br>        buy1 = Math.max(buy1,-prices[i]);<br>        sell1 = Math.max(sell1,buy1+prices[i]);<br>        buy2 = Math.max(buy2,sell1-prices[i]);<br>        sell2 = Math.max(sell2,buy2+prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p><strong>题目</strong>：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [0,1,0,3,12]</p><p>输出：[1,3,12,0,0]</p></blockquote><p><strong>思路</strong>：快慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,fast = slow,len = nums.length;<br>    <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[slow];<br>            nums[slow] = nums[fast];<br>            nums[fast] = temp;<br>            slow++;<br>            fast++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            fast++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><strong>题目</strong>：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p><strong>示例</strong>：</p><blockquote><p>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p></blockquote><p><strong>思路</strong>：定义两个优先队列，一个小根堆，一个大根堆。保证这两个队列中的元素个数相差不超过一。每次添加一个元素，先和大根堆的堆顶元素比较。比它小则添加到大根堆，然后判断大根堆的元素个数是否大于小根堆的元素个数+1，若大于，则需弹出一个大根堆的元素添加到小根堆。否则添加到小根堆。然后判断小根堆的元素个数是否大于大根堆的元素个数，若大于，则需弹出一个小根堆的元素添加到大根堆。对于中位数，如果两个优先队列元素个数相等则取两个堆的堆顶元素求平均，否则取大根堆的堆顶元素。</p><p>上面太啰嗦了，主要思想就是，用两个堆的堆顶保存中位数，维护这两个堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; minq;<br>PriorityQueue&lt;Integer&gt; maxq;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>    minq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);<br>    maxq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a-b);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-keyword">if</span>(minq.isEmpty()||minq.peek()&gt;=num)&#123;<br>        minq.offer(num);<br>        <span class="hljs-keyword">if</span>(maxq.size()+<span class="hljs-number">1</span>&lt;minq.size())&#123;<br>            maxq.offer(minq.poll());<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        maxq.offer(num);<br>        <span class="hljs-keyword">if</span>(maxq.size()&gt;minq.size())&#123;<br>            minq.offer(maxq.poll());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(minq.size()==maxq.size())&#123;<br>        <span class="hljs-keyword">return</span> (minq.peek()+maxq.peek())/<span class="hljs-number">2.0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> minq.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题5</title>
    <link href="/leetcode-suan-fa-ti-5/"/>
    <url>/leetcode-suan-fa-ti-5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h2><p><strong>题目</strong>：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>操作返回 -1 )</p><p><strong>示例</strong>：</p><blockquote><p>输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>           [[],[3],[],[]]</p><p>输出：[null,null,3,-1]</p></blockquote><p><strong>思路</strong>：一道简单题，用两个栈模拟队列，一个栈只负责进，另一个栈只负责出。当出的栈为空时，将进的栈的所有元素弹出并压入出的栈。这样需要出队时就只用弹出负责出的栈的栈顶元素就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; s1;<br>Stack&lt;Integer&gt; s2;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>    s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    s1.push(value);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(s2.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span>(s1.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!s1.isEmpty())&#123;<br>                s2.push(s1.pop());<br>            &#125;<br>            <span class="hljs-keyword">return</span> s2.pop();<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> s2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p><strong>题目</strong>：给你一个 升序排列 的数组 <code>nums</code>，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组<code>nums</code>的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 <code>nums</code>的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 <code>nums</code>的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums&#x3D; [1,1,2]</p><p>输出：2, nums&#x3D; [1,2,_]</p></blockquote><p><strong>思路</strong>：一道双指针题，用快慢指针。慢指针用来保证删除重复元素后的最后一个数组下标，快指针用来遍历整个数组，将快指针指向的元素与慢指针指向的前一个元素进行比较，相同则快指针往前走一步，不同则说明这是一个不重复的新元素，将其赋值给慢指针，然后各向前走一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,fast = <span class="hljs-number">1</span>,len = nums.length;<br>    <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!=nums[slow-<span class="hljs-number">1</span>])&#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>            fast++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            fast++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h2><p><strong>题目</strong>：给定一个包含红色、白色和蓝色、共 n 个元素的数组 <code>nums</code> ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [2,0,2,1,1,0]</p><p>输出：[0,0,1,1,2,2]</p></blockquote><p><strong>思路</strong>：又是一道双指针题，先定义两个指针，一个指针指向数组头，记录已经排好的0的位置；一个指针指向数组尾，记录已经排好的2的位置，然后对数组进行遍历。如果找到了 0，将其与0指针进行交换，0指针向后移动一个位置；如果找到了2，将其与2指针进行交换，2指针向前移动一个位置；只这样写是不对的，因为我们不能保证交换后的当前值不为2或0，所以我们当我们找到 2 时，我们需要不断地将其与2指针进行交换，直到新的值不为 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt;= b;i++)&#123;<br>        <span class="hljs-keyword">while</span>(i &lt;= b&amp;&amp;nums[i]==<span class="hljs-number">2</span>)&#123;<br>            swap(i,b,nums);<br>            b--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)&#123;<br>            swap(i,a,nums);<br>            a++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题4</title>
    <link href="/leetcode-suan-fa-ti-4/"/>
    <url>/leetcode-suan-fa-ti-4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p><strong>题目</strong>：给你一个大小为 m x n 的二进制矩阵 <code>grid</code>。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 <code>grid</code>的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 <code>grid</code>中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658887229/zhaoxu%60s%20blog/2022/c462d022e77d90bc42de4f86e1ed4e9b.jpg" alt="img"></p><p><strong>示例</strong>：</p><blockquote><p>输入：grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</p><p>输出：6</p></blockquote><p><strong>思路</strong>：经典深度优先搜索题，递归的时候把结果累加。但我写了半天，后来发现是有个变量写错了，看来有时候觉得自己思路没问题的，但结果和自己想的不一样的时候，首先就应该检查一下是不是代码那个地方写错了，看半天，唉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> grid.length,len2 = grid[<span class="hljs-number">0</span>].length,res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; len1;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; len2;j++)&#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                res = Math.max(backTrack(i,j,grid),res);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span>[][] grid)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    grid[i][j]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] directions = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir:directions)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i+dir[<span class="hljs-number">0</span>],y = j+dir[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=grid.length||y&lt;<span class="hljs-number">0</span>||y&gt;=grid[<span class="hljs-number">0</span>].length||grid[x][y]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cnt+=backTrack(x,y,grid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h2><p><strong>题目</strong>：给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 ( 必须有相应的右括号 )。</li><li>任何右括号 ) 必须有相应的左括号 ( 。</li><li>左括号 ( 必须在对应的右括号之前 )。</li><li>*可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例</strong>：</p><blockquote><p>输入：“(*)”</p><p>输出：True</p></blockquote><p><strong>思路一</strong>：利用栈存储符号的下标，遇到左括号就入s1栈，遇到*号入s2栈，遇到右括号优先弹出s1栈中的下标，否则弹出s2栈中的下标，两者都为空则返回false。遍历完成后，再对s1和s2中剩下的下标进行判断，s1的栈顶数据不能大于s2的栈顶数据，否则返回false。最后判断s1是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>    Deque&lt;Integer&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            s1.push(i);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            s2.push(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(!s1.isEmpty())&#123;<br>                s1.pop();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!s2.isEmpty())&#123;<br>                s2.pop();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!s1.isEmpty()&amp;&amp;!s2.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s1.pop(),j = s2.pop();<br>        <span class="hljs-keyword">if</span>(i &gt; j)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s1.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路二</strong>：贪心解法，空间复杂度优化到O(1)。在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，</p><ul><li>如果遇到左括号，则将最小值和最大值分别加 1；</li><li>如果遇到右括号，则将最小值和最大值分别减 1；</li><li>如果遇到星号，则将最小值减 1，将最大值加 1。</li></ul><p>然后在遍历过程中进行判断，最大值不能小于0。再在最后进行判断，最小值必须等于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,min = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            max++;<br>            min++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            min = Math.max(min-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>            max--;<br>            <span class="hljs-keyword">if</span>(max&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            max++;<br>            min = Math.max(min-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min==<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h2><p><strong>题目</strong>：给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>示例</strong>：</p><blockquote><p>输入：nums &#x3D; [10,2]</p><p>输出：”210”</p></blockquote><p><strong>思路</strong>：这道题的关键在于，如果一个数排在另一个数前面组成的数大于排在其后面，则不论几个数进行排序，要得到最大的结果，该数就应该排在前面。也就是说这个顺序具有传递性。根据这一点对数据进行比较并排序，再转化为字符串。（写过的题，又忘了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j &lt; nums.length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(compare(nums[i],nums[j]))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>        res.append(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sx</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>,sy = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(sx&lt;=x)&#123;<br>        sx *= <span class="hljs-number">10</span>;<br>    &#125; <br>    <span class="hljs-keyword">while</span>(sy&lt;=y)&#123;<br>        sy *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> y*sx+x-x*sy-y&gt;<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap详解</title>
    <link href="/hashmap-xiang-jie/"/>
    <url>/hashmap-xiang-jie/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a>HashMap详解</h2><h3 id="HashMap的容量与扩容"><a href="#HashMap的容量与扩容" class="headerlink" title="HashMap的容量与扩容"></a>HashMap的容量与扩容</h3><p><code>HashMap</code>类中有以下主要成员变量：</p><ul><li><p>transient int size;</p><p>记录了Map中KV对的个数</p></li><li><p>loadFactor</p><p>装载因子，用来衡量<code>HashMap</code>满的程度。loadFactor的默认值为0.75f（<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>）。</p></li><li><p>int threshold;</p><p>临界值，当实际KV个数超过threshold时，<code>HashMap</code>会将容量扩容，threshold＝容量*装载因子</p></li><li><p>除了以上这些重要成员变量外，<code>HashMap</code>中还有一个和他们紧密相关的概念：capacity</p><p>容量，如果不指定，默认容量是16(<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>)</p></li></ul><p><code>HashMap</code>的容量为什么是2的整数倍：主要是可以使用按位与替代取模来提升hash的效率。</p><p><code>HashMap</code>的扩容条件是什么：<code>HashMap</code>的扩容条件就是当<code>HashMap</code>中的元素个数（size）超过临界值（threshold）时就会自动扩容。</p><p>在<code>HashMap</code>中，threshold &#x3D; loadFactor * capacity。</p><p>loadFactor是装载因子，表示<code>HashMap</code>满的程度，默认值为0.75f，</p><h3 id="HashMap中hash方法的原理"><a href="#HashMap中hash方法的原理" class="headerlink" title="HashMap中hash方法的原理"></a>HashMap中hash方法的原理</h3><p>hash方法的功能是根据Key来定位这个K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是个int类型的数组下标。先调用hashcode方法返回一个整数，然后在对这个数取模。基本原理就是这个，只不过，在具体实现上，由两个方法<code>int hash(Object k)</code>和<code>int indexFor(int h, int length)</code>来实现。</p><h4 id="HashMap-In-Java-7"><a href="#HashMap-In-Java-7" class="headerlink" title="HashMap In Java 7"></a>HashMap In Java 7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将Object转换成一个整型。</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hashSeed;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>    &#125;<br><br>    h ^= k.hashCode();<br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。</span><br>&#125;<br><span class="hljs-comment">//将hash生成的整型转换成链表数组中的下标。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java用位运算(&amp;)来代替取模运算(%)以提升效率，X % 2^n &#x3D; X &amp; (2^n – 1)，只要保证length的长度是<code>2^n</code>的话，就可以实现取模运算了。</p><h4 id="HashTable-In-Java-7"><a href="#HashTable-In-Java-7" class="headerlink" title="HashTable In Java 7"></a>HashTable In Java 7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object k)</span> &#123;<br>    <span class="hljs-comment">// hashSeed will be zero if alternative hashing is disabled.</span><br>    <span class="hljs-keyword">return</span> hashSeed ^ k.hashCode();<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于只是对k做了个简单的hash，取了一下其hashCode。而HashTable中也没有indexOf方法，取而代之的是这段代码：int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;。也就是说，HashMap和HashTable对于计算数组下标这件事，采用了两种方法。HashMap采用的是位运算，而HashTable采用的是直接取模。</p><ul><li>HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</li><li>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</li></ul><h4 id="HashMap-In-Java-8"><a href="#HashMap-In-Java-8" class="headerlink" title="HashMap In Java 8"></a>HashMap In Java 8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 8中的hash函数，原理和Java 7中基本类似。Java 8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理是不变的。</p><p>以上方法得到的int的hash值，然后再通过h &amp; (table.length -1)来得到该对象在数据中保存的位置。</p><h4 id="HashTable-In-Java-8"><a href="#HashTable-In-Java-8" class="headerlink" title="HashTable In Java 8"></a>HashTable In Java 8</h4><p>在Java 8的HashTable中，已经不再有hash方法了。但是哈希的操作还是在的，比如在put方法中就有如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br><br></code></pre></td></tr></table></figure><p>与java7中区别不大。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合类</title>
    <link href="/java-ji-he-lei/"/>
    <url>/java-ji-he-lei/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658821530/zhaoxu%60s%20blog/2022/1fdd90964ee659bd3a1b83018d2c59bb.png" alt="集合"></p><h2 id="Set和List区别？"><a href="#Set和List区别？" class="headerlink" title="Set和List区别？"></a>Set和List区别？</h2><p><code>List</code>,<code>Set</code>都是继承自<code>Collection</code>接口。都是用来存储一组相同类型的元素的。</p><p><code>List</code>特点：元素有放入顺序，元素可重复 。</p><p><code>Set</code>特点：元素无放入顺序，元素不可重复。</p><h2 id="ArrayList和LinkedList和Vector的区别？"><a href="#ArrayList和LinkedList和Vector的区别？" class="headerlink" title="ArrayList和LinkedList和Vector的区别？"></a>ArrayList和LinkedList和Vector的区别？</h2><p>三者都实现了<code>List </code>接口，</p><p><code>ArrayList </code>是一个可改变大小的数组.当更多的元素加入到<code>ArrayList </code>中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问。</p><p><code>Vector</code> 和<code>ArrayList </code>类似,但属于强同步类，多线程下安全。</p><p><code>LinkedList</code> 是一个双链表,在添加和删除元素时具有比<code>ArrayList </code>更好的性能.但在get与set方面弱于<code>ArrayList </code>.</p><p><code>Vector</code>和<code>ArrayList </code>在更多元素添加进来时会请求更大的空间。<code>Vector</code>每次请求其大小的双倍空间，而<code>ArrayList </code>每次对size增长50%。</p><p>而 <code>LinkedList </code>还实现了<code>Queue</code>接口,该接口比<code>List</code>提供了更多的方法,包括 offer(),peek(),poll()等。</p><h2 id="SynchronizedList和Vector的区别？"><a href="#SynchronizedList和Vector的区别？" class="headerlink" title="SynchronizedList和Vector的区别？"></a>SynchronizedList和Vector的区别？</h2><p><code>Vector</code>是java.util包中的一个类。 <code>SynchronizedList</code>是java.util.Collections中的一个静态内部类。</p><p>在多线程的场景中可以直接使用<code>Vector</code>类，也可以使用Collections.SynchronizedList(List list)方法来返回一个线程安全的<code>List</code>。</p><p><code>Vector</code>使用同步方法实现，<code>SynchronizedList</code>使用同步代码块实现。 2.两者的扩充数组容量方式不一样（两者的add方法在扩容方面的差别也就是<code>ArrayList</code>和<code>Vector</code>的差别。）</p><p><code>SynchronizedList</code>中实现的类并没有都使用synchronized同步代码块。其中有listIterator和listIterator(int index)并没有做同步处理。</p><p><code>SynchronizedList</code>和<code>Vector</code>最主要的区别： </p><p>1.<code>SynchronizedList</code>有很好的扩展和兼容功能。他可以将所有的<code>List</code>的子类转成线程安全的类。</p><p>2.使用<code>SynchronizedList</code>的时候，进行遍历时要手动进行同步处理。 </p><p>3.<code>SynchronizedList</code>可以指定锁定的对象。</p><h2 id="Set如何保证元素不重复"><a href="#Set如何保证元素不重复" class="headerlink" title="Set如何保证元素不重复?"></a>Set如何保证元素不重复?</h2><p>在Java的Set体系中，根据实现方式不同主要分为两大类。<code>HashSet</code>和<code>TreeSet</code>。</p><p>1、<code>TreeSet </code>是二叉树实现的，<code>TreeSet</code>中的数据是自动排好序的，不允许放入 null值<br>2、<code>HashSet</code> 是哈希表实现的，<code>HashSet</code>中的数据是无序的，可以放入 null值，但只能放入一个null，两者中的值都不能重复，就如数据库中的唯一约束</p><p>在<code>HashSet</code>中，基本的操作都是由<code>HashMap</code>底层实现的，因为<code>HashSet</code>底层是用<code>HashMap</code>存储数据的。当向<code>HashSet</code>中添加元素的时候，首先计算元素的hashCode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置为空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p><code>TreeSet</code>的底层是<code>TreeMap</code>的keySet()，而<code>TreeMap</code>是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p><code>TreeMap</code>是按key排序的，元素在插入<code>TreeSet</code>时compareTo()方法要被调用，所以<code>TreeSet</code>中的元素要实现<code>Comparable</code>接口。<code>TreeSet</code>作为一种Set，它不允许出现重复元素。<code>TreeSet</code>是用compareTo()来判断重复元素的。</p><h2 id="HashMap、HashTable、ConcurrentHashMap区别"><a href="#HashMap、HashTable、ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable、ConcurrentHashMap区别"></a>HashMap、HashTable、ConcurrentHashMap区别</h2><h3 id="HashMap和HashTable有何不同？"><a href="#HashMap和HashTable有何不同？" class="headerlink" title="HashMap和HashTable有何不同？"></a>HashMap和HashTable有何不同？</h3><p><strong>线程安全</strong>：<code>HashTable</code> 中的方法是同步的，而<code>HashMap</code>中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用<code>HashTable</code>，但是要使用<code>HashMap</code>的话就要自己增加同步处理了。</p><p><strong>继承关系</strong>： <code>HashTable</code>是基于陈旧的Dictionary类继承来的。 <code>HashMap</code>继承的抽象类AbstractMap实现了Map接口。</p><p><strong>允不允许null值</strong>： <code>HashTable</code>中，key和value都不允许出现null值，否则会抛出NullPointerException异常。 <code>HashMap</code>中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p><p><strong>默认初始容量和扩容机制</strong>： <code>HashTable</code>中的hash数组初始大小是11，增加的方式是 old*2+1。<code>HashMap</code>中hash数组的默认大小是16，而且一定是2的指数。</p><p><strong>哈希值的使用不同</strong> ： <code>HashTable</code>直接使用对象的hashCode。 <code>HashMap</code>重新计算hash值。</p><p><strong>遍历方式的内部实现上不同</strong> ： <code>HashTable</code>、<code>HashMap</code>都使用了 Iterator。而由于历史原因，<code>HashTable</code>还使用了Enumeration的方式 。 <code>HashMap</code> 实现 Iterator，支持fast-fail，<code>Hashtable</code>的 Iterator 遍历支持fast-fail，用 Enumeration 不支持 fast-fail。</p><h3 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h3><p><code>ConcurrentHashMap</code>和<code>HashMap</code>的实现方式不一样，虽然都是使用桶数组实现的，但是还是有区别，<code>ConcurrentHashMap</code>对桶数组进行了分段，而<code>HashMap</code>并没有。</p><p><code>ConcurrentHashMap</code>在每一个分段上都用锁进行了保护。<code>HashMap</code>没有锁机制。所以，前者线程安全的，后者不是线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题3</title>
    <link href="/leetcode-suan-fa-ti-3/"/>
    <url>/leetcode-suan-fa-ti-3/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p><strong>题目</strong>：给你一个 无重复元素 的整数数组<code>candidates</code>和一个目标整数  <code>target</code>，找出<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p><code>candidates</code> 中的同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为  <code>target</code>  的不同组合数少于 150 个。</p><p><strong>示例</strong>：</p><blockquote><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7</p><p>输出：[[2,2,3],[7]]</p></blockquote><p><strong>思路</strong>：回溯的入门级题目，一般回溯的关键都是在于怎么去重。对于这道题，核心在于每次搜索的时候设置下一轮的搜索起点index。由于元素可以重复使用，所以对于同一根节点的节点我们可以重复的遍历，也就是调用第21行，我们可以继续用i作为下层遍历的开始，但对于同一层的节点我们就不能重复使用了，表现在代码上就是第19行，每次都遍历下个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(candidates);<br>    backTrack(candidates,target,re,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,List&lt;Integer&gt; re,<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index;i &lt; candidates.length;i++)&#123;<br>        re.add(candidates[i]);<br>        backTrack(candidates,target-candidates[i],re,i);<br>        re.remove(re.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p><strong>题目</strong>：给定一个候选人编号的集合 <code>candidates</code> 和一个目标数  <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code>的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p><p><strong>示例</strong>：</p><blockquote><p>输入：candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</p><p>输出：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>思路</strong>：与上题思路类似，关键点在于第21行的判断，这个判断的作用是，让同一层级不出现相同的元素，还允许不同层级之间的重复。在一个<code>for</code>循环中所有遍历到的都属于一个层级，所以<code>candidates[i]==candidates[i-1]</code>就限制了同一层级的重复，而<code>i&gt;index</code>则保证了不同层级的重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br>List&lt;Integer&gt; re;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(candidates);<br>    backTrack(<span class="hljs-number">0</span>,candidates,target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index;i &lt; candidates.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        re.add(candidates[i]);<br>        backTrack(i+<span class="hljs-number">1</span>,candidates,target-candidates[i]);<br>        re.remove(re.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p><strong>题目</strong>：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658818290/zhaoxu%60s%20blog/2022/9daebb6ebbdb925763fbd31e9a7aa329.jpg" alt="盛水最多的容器" title="盛水最多的容器"></p><p><strong>示例</strong>：</p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]</p><p>输出：49</p></blockquote><p><strong>思路</strong>：贪心思想，双指针从两边往中间遍历数组，每次只移动值较小的指针，然后计算并保存最大的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = height.length-<span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>        res = Math.max(res,Math.min(height[l],height[r])*(r-l));<br>        <span class="hljs-keyword">if</span>(height[l]&lt;height[r])&#123;<br>            l++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的各种关键字</title>
    <link href="/java-zhong-de-ge-chong-guan-jian-zi/"/>
    <url>/java-zhong-de-ge-chong-guan-jian-zi/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>用于修饰变量，被其修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>java的一个二元操作符，类似于&#x3D;&#x3D;，&gt;，&lt;等操作符，用于判断其左边的对象是否是其右边的类是实例。返回boolean类型。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>用于java多线程，只能用来修饰变量。</p><p><strong>可见性</strong>：被<code>volatile</code>修饰的变量，在被修改后会立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p><p><strong>有序性</strong>：被<code>volatile</code>修饰的变量，会严格按照代码顺序执行，禁止指令重排。</p><p><strong>原子性</strong>：<code>volatile</code>并不保证原子性，在以下两个场景中可以使用<code>volatile</code>来代替<code>synchronized</code>：</p><blockquote><p>1、运算结果并不依赖变量的当前值、</p><p>2、变量不需要与其他状态变量共同参与不变约束。</p></blockquote><p><strong>原理</strong>：处理器和内存之间存在多级缓存，但在多线程的情况下，会存在缓存一致性问题。如果一个变量被<code>volatile</code>所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个<code>volatile</code>在并发编程中，其值在多个缓存中是可见的。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>既可以修饰方法也可以修饰代码块</p><blockquote><p>同步方法通过<code>ACC_SYNCHRONIZED</code>关键字隐式的对方法进行加锁。当线程要执行的方法被标注上<code>ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法。</p><p>同步代码块通过<code>monitorenter</code>和<code>monitorexit</code>执行来进行加锁。当线程执行到<code>monitorenter</code>的时候要先获得所锁，才能执行后面的方法。当线程执行到<code>monitorexit</code>的时候则要释放锁。</p><p>每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。</p></blockquote><p>无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。</p><p>ObjectMonitor类中提供了几个方法，如<code>enter</code>、<code>exit</code>、<code>wait</code>、<code>notify</code>、<code>notifyAll</code>等。<code>sychronized</code>加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。</p><p><strong>可见性</strong>：被<code>synchronized</code>修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p><p>所以，synchronized关键字锁住的对象，其值是具有可见性的。</p><p><strong>有序性</strong>：<code>synchronized</code>是无法禁止指令重排和处理器优化的，但他可以保证同一时间只有一个线程可以访问被其修饰的资源，相当于单线程执行，所以可以保证有序性。</p><p><strong>原子性</strong>：和有序性一样，由于<code>synchronized</code>保证了其修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。所以可以保证原子性。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final是Java中的一个关键字，它所表示的是“这部分是无法修改的”。</p><p>使用 final 可以定义 ：变量、方法、类。</p><p><strong>变量</strong>：如果将变量设置为final，则不能更改final变量的值(它将是常量)。</p><p><strong>方法</strong>：如果任何方法声明为final，则不能覆盖它。</p><p><strong>类</strong>：如果把任何一个类声明为final，则不能继承它。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static用来修饰成员变量和成员方法，也可以形成静态static代码块</p><p><strong>静态变量</strong>：一个类中的静态变量，不属于类的对象或者实例。因为静态变量与所有的对象实例共享，因此他们不具线程安全性。</p><p>通常，静态变量常用final关键来修饰，表示通用资源或可以被所有的对象所使用。</p><p><strong>静态方法</strong>：与静态变量一样，静态方法是属于类而不是实例。</p><p>一个静态方法只能使用静态变量和调用静态方法。通常静态方法通常用于想给其他的类使用而不需要创建实例。</p><p><strong>静态代码块</strong>：Java的静态块是一组指令在类装载的时候在内存中由Java ClassLoader执行。</p><p>静态块常用于初始化类的静态变量。大多时候还用于在类装载时候创建静态资源。</p><p>Java不允许在静态块中使用非静态变量。一个类中可以有多个静态块。静态块只在类装载入内存时，执行一次。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const是Java预留关键字，用于后期扩展用，用法跟final相似，不常用</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题2</title>
    <link href="/leetcode-suan-fa-ti-2/"/>
    <url>/leetcode-suan-fa-ti-2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="剑指Offer51-数组中的逆序对"><a href="#剑指Offer51-数组中的逆序对" class="headerlink" title="剑指Offer51.数组中的逆序对"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指Offer51.数组中的逆序对</a></h2><p><strong>题目</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例</strong>：</p><blockquote><p>输入：[7,5,6,4]</p><p>输出：5</p></blockquote><p><strong>思路</strong>：一眼暴力超时，然后想着能不能用单调栈。发现也不行，单调栈只能得到一个数左右两边第一个比它大或小的数，不能解决本体，所以只能看答案了，毕竟是道困难题。结果答案用归并排序，这是我怎么都想不到的，只用在归并排序中加一行代码就能解决这道题，关键在于归并中并的过程，合并的时候能很容易的计算出一个数的前面有多少个比它大的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    sort(nums,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len]);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left&gt;=right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+((right-left)&gt;&gt;<span class="hljs-number">1</span>);<br>    sort(nums,left,mid,temp);<br>    sort(nums,mid+<span class="hljs-number">1</span>,right,temp);<br>    merge(nums,left,right,temp);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>[] temp)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left,mid = left+((right-left)&gt;&gt;<span class="hljs-number">1</span>),j = mid+<span class="hljs-number">1</span>,cur = left;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&lt;=nums[j])&#123;<br>            temp[cur++] = nums[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            count+=(mid-i+<span class="hljs-number">1</span>);<br>            temp[cur++] = nums[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>        temp[cur++] = nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=right)&#123;<br>        temp[cur++] = nums[j++];<br>    &#125;<br>    cur = left;<br>    <span class="hljs-keyword">while</span>(cur&lt;=right)&#123;<br>        nums[cur] = temp[cur];<br>        cur++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-II-077-链表排序"><a href="#剑指-Offer-II-077-链表排序" class="headerlink" title="剑指 Offer II 077. 链表排序"></a><a href="https://leetcode.cn/problems/7WHec2/">剑指 Offer II 077. 链表排序</a></h2><p><strong>题目</strong>：给定链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658731598/zhaoxu%60s%20blog/2022/ef6fb1f39c8b265b7bfb4170bbae8866.jpg" alt="链表排序" title="链表排序"></p><p><strong>思路</strong>：复习上一道题的归并排序，一道链表的归并排序题。关键点在于10和11行的断尾操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">return</span> sort(head,<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode head,ListNode tail)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head.next==tail)&#123;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head,fast = slow;<br>    <span class="hljs-keyword">while</span>(fast!=tail&amp;&amp;fast.next!=tail)&#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> sort(head,slow);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> sort(slow,tail);<br>    <span class="hljs-keyword">return</span> meger(first,second);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">meger</span><span class="hljs-params">(ListNode first,ListNode second)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>),cur = dummyHead;<br>    <span class="hljs-keyword">while</span>(first!=<span class="hljs-literal">null</span>&amp;&amp;second!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(first.val&lt;=second.val)&#123;<br>            cur.next = first;<br>            first = first.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur.next = second;<br>            second = second.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(first!=<span class="hljs-literal">null</span>)&#123;<br>        cur.next = first;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(second!=<span class="hljs-literal">null</span>)&#123;<br>        cur.next = second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo个人博客搭建1</title>
    <link href="/hexo-ge-ren-bo-ke-da-jian-1/"/>
    <url>/hexo-ge-ren-bo-ke-da-jian-1/</url>
    
    <content type="html"><![CDATA[<p>简略介绍一下本博客的搭建过程，如果你也想搭建博客的话，也算是提供一种思路。详细的教程就不写了。</p><span id="more"></span><h1 id="Hexo-Github搭建博客网站介绍"><a href="#Hexo-Github搭建博客网站介绍" class="headerlink" title="Hexo+Github搭建博客网站介绍"></a>Hexo+Github搭建博客网站介绍</h1><p>本来想详细写写我怎么搭建这个网站的，想了想还是算了，毕竟网上有好多比较好的教程了。那就把我搭建也是学习的过程说明一下，也方便以后我对其进行维护。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658820351/zhaoxu%60s%20blog/2022/bfd790f1ac4d0dc1d9e098f8b0727d3c.png" alt="Hexo+GitHub"></p><h2 id="1-Hexo建立网站"><a href="#1-Hexo建立网站" class="headerlink" title="1.Hexo建立网站"></a>1.Hexo建立网站</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658664215/zhaoxu%60s%20blog/2022/6890485c84748900d9dae824b7f7cbb1.png" alt="hexo" title="hexo" style="zoom: 50%;" /></div><br/><p>一个快速、简洁且高效的博客框架，使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页，具体的安装过程可以在<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>进行查阅。</p><h2 id="2-GitHub托管代码"><a href="#2-GitHub托管代码" class="headerlink" title="2.GitHub托管代码"></a>2.GitHub托管代码</h2><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669169/zhaoxu%60s%20blog/2022/6a7440baee823b7f5ab73a15071826a9.png" alt="GitHub Pages" title="GitHub Pages"></p><p>利用hexo生成博客的代码后，我们还需要发布网站，让我们的网站可以被别人访问。而GItHub page则允许我们免费使用，将我们的页面展示到互联网。具体的使用可参阅<a href="https://docs.github.com/cn/pages/getting-started-with-github-pages">Github page官网</a>。</p><p>github和hexo怎么结合使用的详细过程可以参阅知乎的这篇<a href="https://zhuanlan.zhihu.com/p/26625249">文章</a>。</p><h2 id="3-Fluid主题的使用"><a href="#3-Fluid主题的使用" class="headerlink" title="3.Fluid主题的使用"></a>3.Fluid主题的使用</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669257/zhaoxu%60s%20blog/2022/6b0cfa7891dbcc1a7da696be94581113.png" alt="Fluid" title="Fluid" style="zoom:50%;" /></div><p>如果只使用hexo的原版页面也不是不能写博客，不过hexo的<a href="https://hexo.io/themes/">主题市场</a>提供了很多五花八门的主题供我们选择。我选择了<a href="https://hexo.fluid-dev.com/docs/start/">fluid</a>这款主题，主要是该主题的文档是中文的，而且尤其的详细，简直是萌新之友。</p><div align="left"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658669294/zhaoxu%60s%20blog/2022/4296b26c8971fe4d12a1e24f9fb98719.png" alt="fluid的配置指南" title="fluid的配置指南" style="zoom:80%;" /></div><br/><p>通过这篇文档还学到很多主题的玩法，真的受益匪浅。</p><h2 id="4-Waline评论功能集成"><a href="#4-Waline评论功能集成" class="headerlink" title="4.Waline评论功能集成"></a>4.Waline评论功能集成</h2><div align="center"><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658670164/zhaoxu%60s%20blog/2022/f17008f4d71403caac8c37a7dd66061e.png" alt="image-20220724214242749" style="zoom:50%;" /></div><br/><p>通过阅读fluid的文档了解到其很好的集成了各种各样的评论功能，然后就选择了Waline作为该博客的评论系统。也是对着<a href="https://waline.js.org/guide/get-started.html">Waline</a>的文档进行一步一步的配置，没什么特别的。</p><h2 id="5-LeanCloud设置-数据库"><a href="#5-LeanCloud设置-数据库" class="headerlink" title="5.LeanCloud设置(数据库)"></a>5.LeanCloud设置(数据库)</h2><p>Waline评论系统的数据库，也可以用来统计网站的PV与UV数据，主要是fluid都集成好了，不需要进行太多的配置就能使用。<a href="https://console.leancloud.app/apps">LeanCloud官网</a></p><h2 id="6-Vercel部署-服务端"><a href="#6-Vercel部署-服务端" class="headerlink" title="6.Vercel部署(服务端)"></a>6.Vercel部署(服务端)</h2><p>Waline评论系统的服务端，后面我发现也可以用来部署博客，还是完全免费的。简直不要太好用。<a href="https://vercel.com/dashboard">Vercel官网</a></p><p>以上就是我部署该博客网站的过程了，该文章并不算是一个教程，主要是用来记录一下。谢谢你的阅读。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法题1</title>
    <link href="/leetcode-suan-fa-ti-1/"/>
    <url>/leetcode-suan-fa-ti-1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112.路径总和</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658456820/zhaoxu%60s%20blog/2022/zvmf91dubran2qviuwlr.jpg" alt="二叉树" title="二叉树"></p><p><strong>思路</strong>：一道简单题，没有什么好说的，递归深搜就完事了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> root.val==targetSum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.right,targetSum-root.val)||hasPathSum(root.left,targetSum-root.val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113.路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和 II</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658584569/zhaoxu%60s%20blog/2022/1a579f9ff7f6c496afe1e6e82e94aef8.jpg" alt="二叉树2" title="二叉树2"></p><p><strong>思路</strong>：与上题类似，不同的是这个要返回路径。一道基本的回溯题，关键在于什么时候回溯，将添加放在加入结果集的前面，然后不用返回，这样就可以把最后进入结果集的节点删除。这是关键，原来写过类似的，加深下印象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    List&lt;Integer&gt; re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backTrack(root,targetSum,re);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> targetSum,List&lt;Integer&gt; re)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    re.add(root.val);<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.val==targetSum)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>    &#125;<br>    backTrack(root.left,targetSum-root.val,re);<br>    backTrack(root.right,targetSum-root.val,re);<br>    re.remove(re.size()-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径求和-III"><a href="#437-路径求和-III" class="headerlink" title="437.路径求和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437.路径求和 III</a></h2><p><strong>题目</strong>：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658586638/zhaoxu%60s%20blog/2022/6bdf3a6b74f892a62ab38fcde3f9c147.jpg" alt="二叉树3" title="二叉树3"></p><p><strong>思路</strong>：与前面两道题不同，这道题的关键在于如何递归的处理并遍历整个树，使其不重复。看评论区这个操作叫双重递归，从每个节点开始进行类似的计算，用第一个递归用来遍历这些节点，第二个递归用来处理这些节点，进行深搜。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> pathSumWithRoot(root,targetSum)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSumWithRoot</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">long</span> targetSum)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root.val==targetSum)&#123;<br>        res++;<br>    &#125;<br>    res += pathSumWithRoot(root.left,targetSum-root.val);<br>    res += pathSumWithRoot(root.right,targetSum-root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My first page</title>
    <link href="/my-first-page/"/>
    <url>/my-first-page/</url>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这篇博文主要用来学习markdown的基本语法</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>Java</li><li>C++</li><li>Python</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello world<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>后来我发现了Typora这个软件，实在是好用，才知道markdown根本不用学。</p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
