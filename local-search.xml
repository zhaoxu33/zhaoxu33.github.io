<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo个人博客搭建1</title>
    <link href="/hexo-ge-ren-bo-ke-da-jian-1/"/>
    <url>/hexo-ge-ren-bo-ke-da-jian-1/</url>
    
    <content type="html"><![CDATA[<p>简略介绍一下本博客的搭建过程，如果你也想搭建博客的话，也算是提供一种思路。详细的教程就不写了。</p><span id="more"></span><h2 id="Hexo-Github搭建博客网站介绍"><a href="#Hexo-Github搭建博客网站介绍" class="headerlink" title="Hexo+Github搭建博客网站介绍"></a>Hexo+Github搭建博客网站介绍</h2><p>本来想详细写写我怎么搭建这个网站的，想了想还是算了，毕竟网上有好多比较好的教程了。那就把我搭建也是学习的过程说明一下，也方便以后我对其进行维护。</p><h3 id="Hexo建立网站"><a href="#Hexo建立网站" class="headerlink" title="Hexo建立网站"></a>Hexo建立网站</h3><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658664215/zhaoxu%60s%20blog/2022/6890485c84748900d9dae824b7f7cbb1.png" alt="img"></p><p>一个快速、简洁且高效的博客框架，使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。具体的安装过程可以在<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>进行查阅。</p><h3 id="GitHub托管代码"><a href="#GitHub托管代码" class="headerlink" title="GitHub托管代码"></a>GitHub托管代码</h3><p>利用hexo生成博客的代码后，我们还需要发布网站，让我们的网站可以被别人访问。而GItHub page则允许我们免费使用，将我们的页面展示到互联网。具体的使用可参阅<a href="https://docs.github.com/cn/pages/getting-started-with-github-pages">Github page官网</a>。</p><p>github和hexo怎么结合使用的详细过程可以参阅知乎的这篇<a href="https://zhuanlan.zhihu.com/p/26625249">文章</a>。</p><h3 id="Fluid主题的使用"><a href="#Fluid主题的使用" class="headerlink" title="Fluid主题的使用"></a>Fluid主题的使用</h3><p>如果只使用hexo的原版页面也不是不能写博客，不过hexo的<a href="https://hexo.io/themes/">主题市场</a>提供了很多五花八门的主题供我们选择。我选择了<a href="https://hexo.fluid-dev.com/docs/start/">fluid</a>这款主题，主要是该主题的文档是中文的，而且尤其的详细，简直是萌新之友。通过这篇文档还学到很多主题的玩法，真的受益匪浅。</p><h3 id="Waline评论功能集成"><a href="#Waline评论功能集成" class="headerlink" title="Waline评论功能集成"></a>Waline评论功能集成</h3><p>通过阅读fluid的文档了解到其很好的集成了各种各样的评论功能，然后就选择了Waline作为该博客的评论系统。也是对着<a href="https://waline.js.org/guide/get-started.html">Waline</a>的文档进行一步一步的配置，没什么特别的。</p><h3 id="LeanCloud设置-数据库"><a href="#LeanCloud设置-数据库" class="headerlink" title="LeanCloud设置(数据库)"></a>LeanCloud设置(数据库)</h3><p>Waline评论系统的数据库，也可以用来统计网站的PV与UV数据，主要是fluid都集成好了，不需要进行太多的配置就能使用。<a href="https://console.leancloud.app/apps">LeanCloud官网</a></p><h3 id="Vercel部署-服务端"><a href="#Vercel部署-服务端" class="headerlink" title="Vercel部署(服务端)"></a>Vercel部署(服务端)</h3><p>Waline评论系统的服务端，后面我发现也可以用来部署博客，还是完全免费的。简直不要太好用，<a href="https://vercel.com/dashboard">Vercel官网</a></p><p>以上就是我部署该博客网站的过程了，该文章并不算是一个教程，主要是用来记录一下。谢谢你的阅读。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题日记1</title>
    <link href="/leetcode-shua-ti-ri-ji-1/"/>
    <url>/leetcode-shua-ti-ri-ji-1/</url>
    
    <content type="html"><![CDATA[<p>几道二叉树的路径求和题，原来写过，现在又忘了，果然刷题只有重复、重复、再重复！</p><span id="more"></span><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112.路径总和</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。<br><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658456820/zhaoxu%60s%20blog/2022/zvmf91dubran2qviuwlr.jpg" alt="二叉树" title="二叉树"></p><p><strong>思路</strong>：一道简单题，没有什么好说的，递归深搜就完事了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> root.val==targetSum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.right,targetSum-root.val)||hasPathSum(root.left,targetSum-root.val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113.路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和 II</a></h2><p><strong>题目</strong>：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658584569/zhaoxu%60s%20blog/2022/1a579f9ff7f6c496afe1e6e82e94aef8.jpg" alt="二叉树2" title="二叉树2"></p><p><strong>思路</strong>：与上题类似，不同的是这个要返回路径。一道基本的回溯题，关键在于什么时候回溯，将添加放在加入结果集的前面，然后不用返回，这样就可以把最后进入结果集的节点删除。这是关键，原来写过类似的，加深下印象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    List&lt;Integer&gt; re = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    backTrack(root,targetSum,re);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> targetSum,List&lt;Integer&gt; re)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    re.add(root.val);<br>    <span class="hljs-keyword">if</span>(root.left==<span class="hljs-literal">null</span>&amp;&amp;root.right==<span class="hljs-literal">null</span>&amp;&amp;root.val==targetSum)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(re));<br>    &#125;<br>    backTrack(root.left,targetSum-root.val,re);<br>    backTrack(root.right,targetSum-root.val,re);<br>    re.remove(re.size()-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径求和-III"><a href="#437-路径求和-III" class="headerlink" title="437.路径求和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437.路径求和 III</a></h2><p><strong>题目</strong>：给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><img src="https://res.cloudinary.com/davg6ekyb/image/upload/v1658586638/zhaoxu%60s%20blog/2022/6bdf3a6b74f892a62ab38fcde3f9c147.jpg" alt="二叉树3" title="二叉树3"></p><p><strong>思路</strong>：与前面两道题不同，这道题的关键在于如何递归的处理并遍历整个树，使其不重复。看评论区这个操作叫双重递归，从每个节点开始进行类似的计算，用第一个递归用来遍历这些节点，第二个递归用来处理这些节点，进行深搜。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> pathSumWithRoot(root,targetSum)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSumWithRoot</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">long</span> targetSum)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root.val==targetSum)&#123;<br>        res++;<br>    &#125;<br>    res += pathSumWithRoot(root.left,targetSum-root.val);<br>    res += pathSumWithRoot(root.right,targetSum-root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first page</title>
    <link href="/my-first-page/"/>
    <url>/my-first-page/</url>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这篇博文主要用来学习markdown的基本语法</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>文本1</li><li>文本2</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hello world<br></code></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
